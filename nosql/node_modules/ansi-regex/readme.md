---
ms.openlocfilehash: 79b8bd5d8af7fd6d79dcb7c24b3f2e03e1d2a029
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052618"
---
# <a name="ansi-regex-build-statushttpstravis-ciorgchalkansi-regex"></a>ansi-regex [![빌드 상태](https://travis-ci.org/chalk/ansi-regex.svg?branch=master)](https://travis-ci.org/chalk/ansi-regex)

> [ANSI 이스케이프 코드](http://en.wikipedia.org/wiki/ANSI_escape_code) 일치를 위한 정규식


## <a name="install"></a>설치

```
$ npm install --save ansi-regex
```


## <a name="usage"></a>사용량

```js
const ansiRegex = require('ansi-regex');

ansiRegex().test('\u001b[4mcake\u001b[0m');
//=> true

ansiRegex().test('cake');
//=> false

'\u001b[4mcake\u001b[0m'.match(ansiRegex());
//=> ['\u001b[4m', '\u001b[0m']
```

## <a name="faq"></a>FAQ

### <a name="why-do-you-test-for-codes-not-in-the-ecma-48-standard"></a>ECMA 48 표준에 없는 코드를 테스트하는 이유는 무엇인가요?

테스트로 실행하는 코드 중 일부는 비표준 또는 제조업체별 코드의 다양한 목록을 찾기 위해 얻은 코드입니다. 제 기억이 맞다면 대부분의 코드가 동일하거나 유사한 형식을 따르고 실제 문자열 콘텐츠를 제거할 위험 없이 문자열에서 안전하게 일치시킬 수 있으므로 표준 코드와 비표준 코드를 모두 테스트합니다. 기존의 형식(즉, 숫자로 끝남)을 따르지 않는 몇 가지 비표준 제어 코드가 있으므로 이를 안정적으로 일치시킬 수 없기 때문에 테스트에서 제외해야 합니다.

역사적 측면에서 볼 때 이러한 ECMA 표준은 90년대 초에 확립된 반면, 예를 들어 VT100은 70년대 중후반에 설계되었습니다. 이 시점에서 제어 코드는 여전히 관리되지 않았으며 엔지니어는 소유되었을 수 있는 하드웨어 포트를 활성화하기 위해 이를 다양한 작업에 사용했습니다. 다른 곳에서는 유사한 ‘무정부 상태’ 코드가 프로세서용 x86 아키텍처에 있습니다. 특정 브랜드의 프로세서에서 다른 의미를 가질 수 있는 수많은 “인터럽트”가 있으며 대부분은 단계적으로 제거되었습니다.


## <a name="license"></a>License

MIT © [Sindre Sorhus](http://sindresorhus.com)
