---
ms.openlocfilehash: 75916065970faa645bca603327ecbaea09afe12e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138053055"
---
# <a name="safe-buffer-travistravis-imagetravis-url-npmnpm-imagenpm-url-downloadsdownloads-imagedownloads-url-javascript-style-guidestandard-imagestandard-url"></a>safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![다운로드][downloads-image]][downloads-url] [![javascript 스타일 가이드][standard-image]][standard-url]

[travis-image]: https://img.shields.io/travis/feross/safe-buffer/master.svg
[travis-url]: https://travis-ci.org/feross/safe-buffer
[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
[npm-url]: https://npmjs.org/package/safe-buffer
[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
[downloads-url]: https://npmjs.org/package/safe-buffer
[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg
[standard-url]: https://standardjs.com

#### <a name="safer-nodejs-buffer-api"></a>더 안전한 Node.js 버퍼 API

**모든 버전의 Node.js에서 새로운 Node.js 버퍼 API(`Buffer.from`, `Buffer.alloc`, `Buffer.allocUnsafe`, `Buffer.allocUnsafeSlow`)를 사용합니다.**

**사용 가능한 경우 기본 제공 구현을 사용합니다.**

## <a name="install"></a>설치

```
npm install safe-buffer
```

## <a name="usage"></a>usage

이 패키지의 목표는 node.js `Buffer`에 대한 안전한 대체를 제공하는 것입니다.

`Buffer`에 대한 드롭인 대체입니다. node.js 모듈의 맨 위에 하나의 `require` 줄을 추가하여 사용할 수 있습니다.

```js
var Buffer = require('safe-buffer').Buffer

// Existing buffer code will continue to work without issues:

new Buffer('hey', 'utf8')
new Buffer([1, 2, 3], 'utf8')
new Buffer(obj)
new Buffer(16) // create an uninitialized buffer (potentially unsafe)

// But you can use these new explicit APIs to make clear what you want:

Buffer.from('hey', 'utf8') // convert from many types to a Buffer
Buffer.alloc(16) // create a zero-filled buffer (safe)
Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
```

## <a name="api"></a>api

### <a name="class-method-bufferfromarray"></a>클래스 메서드: Buffer.from(배열)
<!-- YAML
added: v3.0.0
-->

* `array` {Array}

옥텟의 `array`를 사용하여 새 `Buffer`를 할당합니다.

```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

`array`가 `Array`가 아니면 `TypeError`가 throw됩니다.

### <a name="class-method-bufferfromarraybuffer-byteoffset-length"></a>클래스 메서드: Buffer.from(arrayBuffer[, byteOffset[, 길이]])
<!-- YAML
added: v5.10.0
-->

* `arrayBuffer` {ArrayBuffer} `TypedArray` 또는 `new ArrayBuffer()`의 `.buffer` 속성
* `byteOffset` {Number} 기본값: `0`
* `length` {Number} 기본값: `arrayBuffer.length - byteOffset`

`TypedArray` 인스턴스의 `.buffer` 속성에 대한 참조를 전달하면 새로 생성된 `Buffer`는 TypedArray와 동일한 할당된 메모리를 공유합니다.

```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

선택적 `byteOffset` 및 `length` 인수는 `Buffer`에서 공유할 `arrayBuffer` 내에서 메모리 범위를 지정합니다.

```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```

`arrayBuffer`가 `ArrayBuffer`가 아니면 `TypeError`가 throw됩니다.

### <a name="class-method-bufferfrombuffer"></a>클래스 메서드: Buffer.from(버퍼)
<!-- YAML
added: v3.0.0
-->

* `buffer` {Buffer}

전달된 `buffer` 데이터를 새 `Buffer` 인스턴스에 복사합니다.

```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

`buffer`가 `Buffer`가 아닌 경우 `TypeError`가 throw됩니다.

### <a name="class-method-bufferfromstr-encoding"></a>클래스 메서드: Buffer.from(str[, 인코딩])
<!-- YAML
added: v5.10.0
-->

* `str` {String} 인코딩할 문자열입니다.
* `encoding` {String} 사용할 인코딩, 기본값: `'utf8'`

지정된 JavaScript 문자열 `str`를 포함하는 새 `Buffer`를 만듭니다. 제공된 경우 `encoding` 매개 변수는 문자 인코딩을 식별합니다.
지정하지 않으면 `encoding`의 기본값은 `'utf8'`입니다.

```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

`str`가 문자열이 아닌 경우 `TypeError`가 throw됩니다.

### <a name="class-method-bufferallocsize-fill-encoding"></a>클래스 메서드: Buffer.alloc(크기[, 채우기[, 인코딩]])
<!-- YAML
added: v5.10.0
-->

* `size` {Number}
* `fill` {Value} 기본값: `undefined`
* `encoding` {String} 기본값: `utf8`

`size` 바이트의 새 `Buffer`를 할당합니다. `fill`이 `undefined`인 경우 `Buffer`는 0으로 채워집니다.

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`size`는 `require('buffer').kMaxLength`(64비트 아키텍처에서 `kMaxLength`는 `(2^31)-1`) 값보다 작거나 같아야 합니다. 그렇지 않으면 [`RangeError`][]가 throw됩니다. 0보다 작거나 같은 `size`가 지정되면 길이가 0인 버퍼가 만들어집니다.

`fill`이 지정된 경우 할당된 `Buffer`는 `buf.fill(fill)`을 호출하여 초기화됩니다. 자세한 내용은 [`buf.fill()`][]을 참조하세요.

```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```

`fill` 및 `encoding`이 지정된 경우 `buf.fill(fill, encoding)`을 호출하여 할당된 `Buffer`가 초기화됩니다. 예를 들면 다음과 같습니다.

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

`Buffer.alloc(size)`를 호출하면 대체 `Buffer.allocUnsafe(size)`보다 훨씬 느려질 수 있지만 새로 만든 `Buffer` 인스턴스 콘텐츠에 중요한 데이터가 포함되지 않도록 합니다.

`size`가 숫자가 아닌 경우 `TypeError`가 throw됩니다.

### <a name="class-method-bufferallocunsafesize"></a>클래스 메서드: Buffer.allocUnsafe(크기)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

`size` 바이트의 새 0이 아닌 값으로 채워진 `Buffer`를 할당합니다.  `size`는 `require('buffer').kMaxLength`(64비트 아키텍처에서 `kMaxLength`는 `(2^31)-1`) 값보다 작거나 같아야 합니다. 그렇지 않으면 [`RangeError`][]가 throw됩니다. 0보다 작거나 같은 `size`가 지정되면 길이가 0인 버퍼가 만들어집니다.

이러한 방식으로 만든 `Buffer` 인스턴스의 기본 메모리는 초기화되지 않습니다. 새로 만든 `Buffer`의 콘텐츠는 알 수 없으며 중요한 데이터를 포함할 수 있습니다. [`buf.fill(0)`][]을 사용하여 이러한 `Buffer` 인스턴스를 0으로 초기화합니다.

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`size`가 숫자가 아닌 경우 `TypeError`가 throw됩니다.

`Buffer` 모듈은 `size`가 `Buffer.poolSize >> 1`(2로 나눈 `Buffer.poolSize`의 최솟값)보다 작거나 같은 경우에만 `Buffer.allocUnsafe(size)`(및 사용되지 않는 `new Buffer(size)` 생성자)를 사용하여 만든 새 `Buffer` 인스턴스의 빠른 할당을 위해 풀로 사용되는 크기 `Buffer.poolSize`의 내부 `Buffer` 인스턴스를 미리 할당합니다. `Buffer.poolSize`의 기본값은 `8192`이지만 수정할 수 있습니다.

이 미리 할당된 내부 메모리 풀의 사용은 `Buffer.alloc(size, fill)` 호출과 `Buffer.allocUnsafe(size).fill(fill)` 호출의 주요 차이점입니다. 특히, `Buffer.alloc(size, fill)`은 내부 버퍼 풀을 절대 사용하지 않는 반면 `Buffer.allocUnsafe(size).fill(fill)`은 `size`가 `Buffer.poolSize`의 절반보다 작거나 같은 경우 내부 버퍼 풀을 사용합니다.  차이점은 미묘하지만 `Buffer.allocUnsafe(size)`에서 제공하는 애플리케이션에 제공되는 추가 성능이 필요한 경우 중요할 수 있습니다.

### <a name="class-method-bufferallocunsafeslowsize"></a>클래스 메서드: Buffer.allocUnsafeSlow(크기)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

`size` 바이트의 새 0이 아닌 값으로 채워진 항목 및 풀링되지 않은 `Buffer`를 할당합니다.  `size`는 `require('buffer').kMaxLength`(64비트 아키텍처에서 `kMaxLength`는 `(2^31)-1`) 값보다 작거나 같아야 합니다. 그렇지 않으면 [`RangeError`][]가 throw됩니다. 0보다 작거나 같은 `size`가 지정되면 길이가 0인 버퍼가 만들어집니다.

이러한 방식으로 만든 `Buffer` 인스턴스의 기본 메모리는 초기화되지 않습니다. 새로 만든 `Buffer`의 콘텐츠는 알 수 없으며 중요한 데이터를 포함할 수 있습니다. [`buf.fill(0)`][]을 사용하여 이러한 `Buffer` 인스턴스를 0으로 초기화합니다.

`Buffer.allocUnsafe()`를 사용하여 새 `Buffer` 인스턴스를 할당하는 경우 4KB 미만의 할당은 기본적으로 미리 할당된 단일 `Buffer`에서 분할됩니다. 이렇게 하면 애플리케이션이 개별적으로 할당된 많은 버퍼를 만드는 가비지 수집 오버헤드를 방지할 수 있습니다. 이 방법은 최대한 많은 `Persistent` 개체를 추적하고 정리할 필요가 없도록 하여 성능 및 메모리 사용량을 모두 향상시킵니다.

그러나 개발자가 확정되지 않은 시간 동안 풀에서 작은 메모리 청크를 유지해야 하는 경우 `Buffer.allocUnsafeSlow()`를 사용하여 풀링되지 않은 버퍼 인스턴스를 만든 다음, 관련 비트를 복사하는 것이 적절할 수 있습니다.

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

`Buffer.allocUnsafeSlow()`는 개발자가 애플리케이션에서 과도한 메모리 보유를 관찰한 후에만 최후의 수단으로만 사용해야 합니다.

`size`가 숫자가 아닌 경우 `TypeError`가 throw됩니다.

### <a name="all-the-rest"></a>모든 나머지

나머지 `Buffer` API는 node.js의 항목과 정확히 동일합니다.
[문서를 참조하세요](https://nodejs.org/api/buffer.html).


## <a name="related-links"></a>관련 링크

- [Node.js 이슈: 버퍼(숫자)가 안전하지 않음](https://github.com/nodejs/node/issues/4660)
- [Node.js 향상된 기능 제안: Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() soft-deprecate](https://github.com/nodejs/node-eps/pull/4)

## <a name="why-is-buffer-unsafe"></a>`Buffer`가 안전하지 않은 이유는 무엇인가요?

현재 node.js `Buffer` 생성자는 `String`, `Array`, `Object`, `TypedArrayView`(`Uint8Array` 등), `ArrayBuffer`, `Number`와 같은 다양한 인수 형식을 처리하기 위해 오버로드됩니다.

API는 편의를 위해 최적화되어 있습니다. 모든 형식을 throw할 수 있으며 원하는 작업을 수행하려고 합니다.

버퍼 생성자는 매우 강력하기 때문에 다음과 같은 코드가 표시되는 경우가 많습니다.

```js
// Convert UTF-8 strings to hex
function toHex (str) {
  return new Buffer(str).toString('hex')
}
```

하지만 `toHex`가 `Number` 인수와 함께 호출되면 어떻게 됩니까?

### <a name="remote-memory-disclosure"></a>원격 메모리 공개

공격자가 프로그램에서 `Number` 인수를 사용하여 `Buffer` 생성자를 호출할 수 있는 경우 node.js 프로세스에서 초기화되지 않은 메모리를 할당하도록 만들 수 있습니다.
이로 인해 잠재적으로 TLS 프라이빗 키, 사용자 데이터 또는 데이터베이스 암호가 공개될 수 있습니다.

`Buffer` 생성자에 `Number` 인수가 전달되면 지정된 `size`의 **UNINITIALIZED** 메모리 블록이 반환됩니다. 이와 같이 `Buffer`를 만들 때 콘텐츠를 사용자에게 반환하기 전에 **반드시** 덮어써야 합니다.

[node.js 문서](https://nodejs.org/api/buffer.html#buffer_new_buffer_size)에서 다음을 수행합니다.

> `new Buffer(size)`
>
> - `size` 숫자
>
> 이러한 방식으로 만든 `Buffer` 인스턴스의 기본 메모리는 초기화되지 않습니다.
> **새로 만든 `Buffer`의 콘텐츠는 알 수 없으며 중요한 데이터를 포함할 수 있습니다.** `buf.fill(0)`을 사용하여 버퍼를 0으로 초기화합니다.

(우리 자신을 강조합니다.)

프로그래머가 초기화되지 않은 `Buffer`를 만들려고 할 때마다 다음과 같은 코드가 표시되는 경우가 많습니다.

```js
var buf = new Buffer(16)

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="would-this-ever-be-a-problem-in-real-code"></a>실제 코드에서 문제가 되나요?

예. JavaScript와 같은 동적 형식의 언어로 변수의 형식을 확인하는 것을 잊어버리는 것은 놀라울 정도로 일반적입니다.

일반적으로 잘못된 형식을 가정하면 프로그램이 catch되지 않은 예외와 충돌한다는 결과가 발생합니다. 그러나 `Buffer` 생성자에 대한 인수 유형을 확인하는 것을 잊어버리는 실패 모드는 더 치명적입니다.

다음은 JSON 페이로드를 가져와서 16진수로 변환하는 취약한 서비스의 예입니다.

```js
// Take a JSON payload {str: "some string"} and convert it to hex
var server = http.createServer(function (req, res) {
  var data = ''
  req.setEncoding('utf8')
  req.on('data', function (chunk) {
    data += chunk
  })
  req.on('end', function () {
    var body = JSON.parse(data)
    res.end(new Buffer(body.str).toString('hex'))
  })
})

server.listen(8080)
```

이 예제에서 http 클라이언트는 다음을 보내야 합니다.

```json
{
  "str": 1000
}
```

그러면 서버에서 초기화되지 않은 1,000바이트의 메모리를 다시 가져옵니다.

이것은 매우 심각한 버그입니다. 원격 공격자가 OpenSSL 프로세스 메모리를 공개할 수 있도록 허용한 [하트블리드 버그](http://heartbleed.com/)와 심각도가 비슷합니다.


### <a name="which-real-world-packages-were-vulnerable"></a>어떤 실제 패키지가 취약합니까?

#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)

[Mathias Buus](https://github.com/mafintosh)와 저([Feross Aboukhadijeh](http://feross.org/))는 자체 패키지 중 하나인 [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)에서 이 문제를 발견했습니다. 이 버그를 사용하면 인터넷의 모든 사용자가 `bittorrent-dht`의 사용자에게 일련의 메시지를 보내고 node.js 프로세스에서 초기화되지 않은 메모리의 20바이트를 한 번에 표시하도록 할 수 있습니다.

다음은 이 문제를 해결한 [커밋](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8)입니다. 새 고정 버전을 릴리스하고, [노드 보안 프로젝트 공개](https://nodesecurity.io/advisories/68)를 만들었으며, 사용자가 최신 버전으로 업그레이드하라는 경고를 받을 수 있도록 npm에서 모든 취약한 버전을 더 이상 사용하지 않습니다.

#### [`ws`](https://www.npmjs.com/package/ws)

그래서 다른 취약한 패키지가 있는지 궁금해했습니다. 물론 우리는 짧은 시간 내에 node.js에서 가장 인기 있는 WebSocket 구현인 [`ws`](https://www.npmjs.com/package/ws)에서 동일한 문제를 발견했습니다.

예상대로 `String` 또는 `Buffer` 대신 `Number` 매개 변수를 사용하여 특정 API를 호출한 경우 초기화되지 않은 서버 메모리가 원격 피어에 공개됩니다.

취약한 메서드는 다음과 같습니다.

```js
socket.send(number)
socket.ping(number)
socket.pong(number)
```

다음은 몇 가지 에코 기능이 있는 취약한 소켓 서버입니다.

```js
server.on('connection', function (socket) {
  socket.on('message', function (message) {
    message = JSON.parse(message)
    if (message.type === 'echo') {
      socket.send(message.data) // send back the user's message
    }
  })
})
```

서버에서 호출된 `socket.send(number)`는 서버 메모리를 공개합니다.

자세한 설명과 함께 문제가 해결된 [릴리스](https://github.com/websockets/ws/releases/tag/1.0.1)는 다음과 같습니다. 빠른 수정을 위한 [Arnout Kazemier](https://github.com/3rd-Eden)에 대한 속성입니다. [노드 보안 프로젝트 공개](https://nodesecurity.io/advisories/67)는 다음과 같습니다.


### <a name="whats-the-solution"></a>솔루션은 무엇인가요?

node.js가 메모리를 빠르게 얻을 수 있는 방법을 제공하는 것이 중요합니다. 그렇지 않으면 성능이 중요한 애플리케이션이 불필요하게 훨씬 느려집니다.

그러나 프로그래머로서 의도를 알릴 더 나은 방법이 필요합니다. **초기화되지 않은 메모리를 원할 때 명시적으로 요청해야 합니다.**

중요한 기능은 다양한 형식을 느슨하게 허용하는 개발자 친화적인 API로 압축하면 안 됩니다. 이 유형의 API는 형식을 매우 신중하게 확인하지 않고 변수를 전달하는 게으른 관행을 권장합니다.

#### <a name="a-new-api-bufferallocunsafenumber"></a>새 API: `Buffer.allocUnsafe(number)`

초기화되지 않은 메모리를 사용하여 버퍼를 만드는 기능은 다른 API의 일부여야 합니다. `Buffer.allocUnsafe(number)`를 제안합니다. 이러한 방식으로 전달되는 모든 종류의 다양한 형식에 대한 사용자 입력을 자주 가져오는 API의 일부가 아닙니다.

```js
var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="how-do-we-fix-nodejs-core"></a>node.js 코어를 해결하려면 어떻게 해야 하나요?

다음과 같은 한 가지 사례를 방어하는 [node.js 코어에 대한 PR](https://github.com/nodejs/node/pull/4514)(`semver-major`로 병합됨)을 보냈습니다.

```js
var str = 16
new Buffer(str, 'utf8')
```

이 경우 프로그래머가 인코딩을 두 번째 인수로 전달했기 때문에 첫 번째 인수를 문자열로 의도했음을 암시합니다. 현재 node.js는 `new Buffer(number, encoding)`의 경우 초기화되지 않은 메모리를 할당합니다. 이는 아마도 프로그래머가 의도한 것이 아닐 것입니다.

그러나 이것은 프로그래머가 `new Buffer(variable)`(`encoding` 매개 변수 없이)을 수행하는 경우 의도한 내용을 알 수 있는 방법이 없기 때문에 이는 부분적인 솔루션일 뿐입니다. `variable`이 때때로 숫자인 경우 초기화되지 않은 메모리가 반환되는 경우가 있습니다.

### <a name="whats-the-real-long-term-fix"></a>실제 장기 수정은 무엇입니까?

초기화되지 않은 메모리가 필요할 때 `new Buffer(number)`를 더 이상 사용하지 않고 제거하고 `Buffer.allocUnsafe(number)`를 사용할 수 있습니다. 그러나 이렇게 하면 1,000개의 패키지가 중단될 것입니다.

~~가장 좋은 솔루션은 다음과 같습니다.~~

~~1. 안전하고 0이 된 메모리를 반환하도록 `new Buffer(number)`를 변경합니다.~~

~~2. 초기화되지 않은 버퍼를 만들기 위한 새 API를 만듭니다. `Buffer.allocUnsafe(number)`를 제안합니다.~~

#### <a name="update"></a>업데이트

이제 세 가지 새 API 추가를 지원합니다.

- `Buffer.from(value)` - 모든 형식에서 버퍼로 변환
- `Buffer.alloc(size)` - 0으로 채워진 버퍼 만들기
- `Buffer.allocUnsafe(size)` - 지정된 크기로 초기화되지 않은 버퍼 만들기

이렇게 하면 `Buffer(variable)`이 숫자 인수를 취하도록 속이는 `ws` 및 `bittorrent-dht`에 영향을 미치는 핵심 문제가 해결됩니다.

이렇게 하면 기존 코드가 계속 작동하며 npm 에코시스템에 미치는 영향은 최소화됩니다. 시간이 지남에 따라 npm 유지 관리자는 성능에 중요한 코드를 마이그레이션하여 `new Buffer(number)` 대신 `Buffer.allocUnsafe(number)`를 사용할 수 있습니다.


### <a name="conclusion"></a>결론

현재 `Buffer` API에 심각한 디자인 문제가 있다고 생각합니다. 친숙한 “개발자 인체공학”을 사용하여 위험 수준이 높은 기능을 편리한 API에 배치하여 안전하지 않은 소프트웨어를 촉진합니다.

이것은 가장 인기 있는 npm 패키지 중 일부에서 문제를 발견했기 때문에 단순한 이론적인 연습이 아니었습니다.

다행히 현재 적용할 수 있는 쉬운 수정 사항이 있습니다. `buffer` 대신 `safe-buffer`를 사용합니다.

```js
var Buffer = require('safe-buffer').Buffer
```

결국 node.js 코어가 이 새롭고 안전한 동작으로 전환할 수 있기를 바랍니다. 우리는 에코시스템에 미치는 영향이 호환성이 손상되는 변경이 아니기 때문에 최소화될 것이라고 생각합니다.
잘 유지 관리되고 인기 있는 패키지는 `Buffer.alloc`을 빠르게 사용하도록 업데이트되지만, 오래되고 안전하지 않은 패키지는 마법처럼 이 공격 벡터로부터 안전해집니다.


## <a name="links"></a>링크

- [Node.js PR: 버퍼: 길이와 enc가 모두 전달되면 throw](https://github.com/nodejs/node/pull/4514)
- [`ws`](https://nodesecurity.io/advisories/67)에 대한 노드 보안 프로젝트 공개
- [`bittorrent-dht`](https://nodesecurity.io/advisories/68)에 대한 노드 보안 프로젝트 공개


## <a name="credit"></a>크레딧

`bittorrent-dht`([공개](https://nodesecurity.io/advisories/68)) 및 `ws`([공개](https://nodesecurity.io/advisories/67))의 원래 문제는 [Mathias Buus](https://github.com/mafintosh) 및 [Feross Aboukhadijeh](http://feross.org/)에 의해 발견되었습니다.

이러한 문제를 공개하고 [노드 보안 프로젝트](https://nodesecurity.io/)를 실행하는 데 도움을 준 [Adam Baldwin](https://github.com/evilpacket)에게 감사드립니다.

이 추가 정보 교정 및 코드 감사에 대한 [John Hiesey](https://github.com/jhiesey)에게 감사드립니다.


## <a name="license"></a>license

MIT. Copyright (C) [Feross Aboukhadijeh](http://feross.org)
