---
ms.openlocfilehash: c0d4bfc80d62125554d466fe2b45375ed815b043
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052433"
---
# <a name="jsonwebtoken"></a>jsonwebtoken

| **빌드** | **종속성** |
|-----------|---------------|
| [![빌드 상태](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![종속성 상태](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


[JSON 웹 토큰](https://tools.ietf.org/html/rfc7519)의 구현입니다.

이는 `draft-ietf-oauth-json-web-token-08`에 대해 개발되었습니다. [node-jws](https://github.com/brianloveswords/node-jws)를 사용합니다.

# <a name="install"></a>설치

```bash
$ npm install jsonwebtoken
```

# <a name="migration-notes"></a>마이그레이션 정보

* [v7에서 v8로](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# <a name="usage"></a>사용량

### <a name="jwtsignpayload-secretorprivatekey-options-callback"></a>jwt.sign(payload, secretOrPrivateKey, [options, callback])

(비동기) 콜백이 제공되면 `err` 또는 JWT를 사용하여 콜백이 호출됩니다.

(동기) JsonWebToken을 문자열로 반환합니다.

`payload`는 유효한 JSON을 나타내는 개체 리터럴, 버퍼 또는 문자열일 수 있습니다. 
> **참고하시기 바랍니다.** `exp` 또는 기타 클레임은 페이로드가 개체 리터럴인 경우에만 설정됩니다. 버퍼 또는 문자열 페이로드는 JSON 유효성을 검사하지 않습니다.

> `payload`가 버퍼 또는 문자열이 아닌 경우 `JSON.stringify`를 사용하여 문자열로 강제 변환됩니다.

`secretOrPrivateKey`는 HMAC 알고리즘의 비밀 또는 RSA 및 ECDSA의 PEM 인코딩 프라이빗 키를 포함하는 문자열, 버퍼 또는 개체입니다. 암호가 있는 프라이빗 키의 경우 `{ key, passphrase }` 개체를 사용할 수 있습니다([암호화 문서](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format) 기반). 이 경우 `algorithm` 옵션을 전달해야 합니다.

`options`:

* `algorithm`(기본값: `HS256`)
* `expiresIn`: 시간 범위 [zeit/ms](https://github.com/zeit/ms)를 설명하는 문자열 또는 초 단위로 표현됩니다. 
  > 예: `60`, `"2 days"`, `"10h"`, `"7d"`. 숫자 값은 초 수로 해석됩니다. 문자열을 사용하는 경우 시간 단위(일, 시간 등)를 제공해야 합니다. 그렇지 않으면 밀리초 단위가 기본적으로 사용됩니다(`"120"`은 `"120ms"`와 같음).
* `notBefore`: 시간 범위 [zeit/ms](https://github.com/zeit/ms)를 설명하는 문자열 또는 초 단위로 표현됩니다. 
  > 예: `60`, `"2 days"`, `"10h"`, `"7d"`. 숫자 값은 초 수로 해석됩니다. 문자열을 사용하는 경우 시간 단위(일, 시간 등)를 제공해야 합니다. 그렇지 않으면 밀리초 단위가 기본적으로 사용됩니다(`"120"`은 `"120ms"`와 같음).
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload`: true이면 서명 함수가 페이로드 개체를 직접 수정합니다. 이는 클레임이 적용된 후 토큰으로 인코딩되기 전에 페이로드에 대한 원시 참조가 필요한 경우에 유용합니다.



> `expiresIn`, `notBefore`, `audience`, `subject`, `issuer`에 대한 기본값은 없습니다.  이러한 클레임은 각각 `exp`, `nbf`, `aud`, `sub`, `iss`를 사용하여 페이로드에 직접 제공할 수도 있지만 두 위치에 모두 포함할 수는 **없습니다**.

`exp`, `nbf`, `iat`는 **NumericDate** 입니다. 관련 [토큰 만료(exp claim)](#token-expiration-exp-claim)를 참조하세요.


`options.header` 개체를 통해 헤더를 사용자 지정할 수 있습니다.

생성된 jwts에는 `noTimestamp`를 지정하지 않는 한 기본적으로 `iat`(발급된) 클레임이 포함됩니다. 페이로드에 `iat`가 삽입되면 `options.expiresIn`의 시간 범위가 지정된 `exp`와 같은 다른 계산을 위해 실제 타임스탬프 대신 사용됩니다.

기본값(HMAC SHA256)을 사용하여 동기 서명

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

RSA SHA256을 사용하여 동기 서명
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
```

비동기적으로 서명
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

jwt 30초 백데이트
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### <a name="token-expiration-exp-claim"></a>토큰 만료(exp 클레임)

JWT 표준은 만료에 대한 `exp` 클레임을 정의합니다. 만료는 **NumericDate** 로 표시됩니다.

> 윤초를 무시하고 지정된 UTC 날짜/시간까지 1970-01-01T00:00:00Z UTC의 초 수를 나타내는 JSON 숫자 값입니다.  이는 IEEE Std 1003.1, 2013 Edition [POSIX.1] 정의 “Epoch 이후의 초”와 동일합니다. 이 정의는 정수가 아닌 값을 나타낼 수 있는 것 외에는 매일 정확히 86,400초로 계산됩니다.  일반적 날짜/시간, 특히 UTC에 대한 자세한 내용은 RFC3339[RFC3339]를 참조하세요.

즉, `exp` 필드에 epoch 이후의 시간(초)이 포함되어야 합니다.

1시간의 만료로 토큰 서명:

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

이 라이브러리를 사용하여 다음과 같은 토큰을 생성하는 또 다른 방법은 다음과 같습니다.

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### <a name="jwtverifytoken-secretorpublickey-options-callback"></a>jwt.verify(token, secretOrPublicKey, [options, callback])

(비동기) 콜백이 제공되면 함수는 비동기적으로 작동합니다. 서명이 유효하고 선택적 만료, 대상 그룹 또는 발급자가 유효한 경우 디코딩된 페이로드를 사용하여 콜백이 호출됩니다. 그렇지 않은 경우 오류와 함께 호출됩니다.

(동기) 콜백이 제공되지 않으면 함수가 동기적으로 작동합니다. 서명이 유효하고 선택적 만료, 대상 그룹 또는 발급자가 유효한 경우 디코딩된 페이로드를 반환합니다. 그렇지 않으면 오류가 throw됩니다.

`token`은 JsonWebToken 문자열입니다.

`secretOrPublicKey`는 HMAC 알고리즘의 비밀 또는 RSA 및 ECDSA에 대한 PEM 인코딩 퍼블릭 키를 포함하는 문자열 또는 버퍼입니다.
`jwt.verify`를 비동기라고 하는 경우 `secretOrPublicKey`는 비밀 또는 퍼블릭 키를 가져와야 하는 함수가 될 수 있습니다. 자세한 예제는 아래를 참조하세요.

[이 주석](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138)에서 언급했듯이 base64로 인코딩된 비밀(base64를 사용하여 인코딩된 임의 바이트)을 예상하는 다른 라이브러리가 있습니다. 이 경우 `Buffer.from(secret, 'base64')`을 전달할 수 있습니다. 이렇게 하면 비밀이 base64를 사용하여 디코딩되고 토큰 확인은 원래 임의의 바이트를 사용합니다.

`options`

* `algorithms`: 허용된 알고리즘의 이름을 가진 문자열 목록입니다. 예: `["HS256", "HS384"]`
* `audience`: 대상 그룹(`aud`)을 확인하려면 여기에 값을 입력합니다. 대상 그룹은 문자열, 정규식 또는 문자열 및/또는 정규식 목록에 대해 확인할 수 있습니다. 
  > 예: `"urn:foo"`, `/urn:f[o]{2}/`, `[/urn:f[o]{2}/, "urn:bar"]`
* `complete`: 페이로드의 일반적인 콘텐츠 대신 디코딩된 `{ payload, header, signature }`를 사용하여 개체를 반환합니다.
* `issuer`(선택 사항): `iss` 필드에 유효한 값의 문자열 또는 문자열 배열입니다.
* `ignoreExpiration`: `true`인 경우 토큰 만료에 대한 유효성을 검사하지 않습니다.
* `ignoreNotBefore`...
* `subject`: 주체(`sub`)를 확인하려면 여기에 값을 입력합니다.
* `clockTolerance`: 여러 서버 간의 작은 클록 차이를 처리하기 위해 `nbf` 클레임 및 `exp` 클레임을 확인할 때 허용할 시간(초)입니다.
* `maxAge`: 토큰이 유효할 수 있는 최대 기간입니다. 시간 범위 [zeit/ms](https://github.com/zeit/ms)를 설명하는 문자열 또는 초 단위로 표현됩니다. 
  > 예: `1000`, `"2 days"`, `"10h"`, `"7d"`. 숫자 값은 초 수로 해석됩니다. 문자열을 사용하는 경우 시간 단위(일, 시간 등)를 제공해야 합니다. 그렇지 않으면 밀리초 단위가 기본적으로 사용됩니다(`"120"`은 `"120ms"`와 같음).
* `clockTimestamp`: 필요한 모든 비교의 현재 시간으로 사용해야 하는 시간(초)입니다.
* `nonce`: `nonce` 클레임을 확인하려면 여기에 문자열 값을 입력합니다. ID 토큰의 Open ID에 사용됩니다. ([Open ID 구현 참고 사항](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes))


```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foo) // bar
});

```

### <a name="jwtdecodetoken--options"></a>jwt.decode(token [, options])

(동기) 서명이 유효한지 확인하지 않고 디코딩된 페이로드를 반환합니다.

> __경고:__ 이는 서명이 유효한지 여부를 확인하지 __않습니다__. 신뢰할 수 없는 메시지에는 사용하지 __않아야__ 합니다. 대신 `jwt.verify`를 사용하려고 할 가능성이 가장 높습니다.

`token`은 JsonWebToken 문자열입니다.

`options`:

* `json`: 헤더에 `"typ":"JWT"`가 포함되지 않은 경우에도 페이로드에서 JSON.parse를 강제 실행합니다.
* `complete`: 디코딩된 페이로드 및 헤더를 사용하여 개체를 반환합니다.

예

```js
// get the decoded payload ignoring signature, no secretOrPrivateKey needed
var decoded = jwt.decode(token);

// get the decoded payload and header
var decoded = jwt.decode(token, {complete: true});
console.log(decoded.header);
console.log(decoded.payload)
```

## <a name="errors--codes"></a>오류 & 코드
확인 중에 throw된 오류가 발생할 수 있습니다.
오류는 확인 콜백의 첫 번째 인수입니다.

### <a name="tokenexpirederror"></a>TokenExpiredError

토큰이 만료되면 throw된 오류입니다.

오류 개체:

* name: ‘TokenExpiredError’
* 메시지: ‘jwt expired’
* expiredAt: [ExpDate]

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'TokenExpiredError',
        message: 'jwt expired',
        expiredAt: 1408621000
      }
    */
  }
});
```

### <a name="jsonwebtokenerror"></a>JsonWebTokenError
오류 개체:

* name: ‘JsonWebTokenError’
* 메시지:
  * ‘jwt 잘못된 형식’
  * ‘jwt 서명이 필요합니다.’
  * ‘유효하지 않은 서명’
  * ‘jwt 대상 그룹이 유효하지 않습니다. 예상: [OPTIONS AUDIENCE]’
  * ‘jwt 발급자가 유효하지 않습니다. 예상: [OPTIONS ISSUER]’
  * ‘jwt ID가 유효하지 않습니다. 예상: [OPTIONS JWT ID]’
  * ‘jwt 주체가 유효하지 않습니다. 예상: [OPTIONS SUBJECT]’

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'JsonWebTokenError',
        message: 'jwt malformed'
      }
    */
  }
});
```

### <a name="notbeforeerror"></a>NotBeforeError
현재 시간이 nbf 클레임 이전이면 throw됩니다.

오류 개체:

* name: ‘NotBeforeError’
* 메시지: ‘jwt not active’
* 날짜: 2018-10-04T16:10:44.000Z

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'NotBeforeError',
        message: 'jwt not active',
        date: 2018-10-04T16:10:44.000Z
      }
    */
  }
});
```


## <a name="algorithms-supported"></a>지원되는 알고리즘

지원되는 알고리즘의 배열입니다. 현재 지원되는 알고리즘은 다음과 같습니다.

alg 매개 변수 값 | 디지털 서명 또는 MAC 알고리즘
----------------|----------------------------
HS256 | SHA-256 해시 알고리즘을 사용하는 HMAC
HS384 | SHA-384 해시 알고리즘을 사용하는 HMAC
HS512 | SHA-512 해시 알고리즘을 사용하는 HMAC
RS256 | SHA-256 해시 알고리즘을 사용하는 RSASSA-PKCS1-v1_5
RS384 | SHA-384 해시 알고리즘을 사용하는 RSASSA-PKCS1-v1_5
RS512 | SHA-512 해시 알고리즘을 사용하는 RSASSA-PKCS1-v1_5
PS256 | SHA-256 해시 알고리즘을 사용하는 RSASSA-PSS(노드 ^6.12.0 또는 >=8.0.0만)
PS384 | SHA-384 해시 알고리즘을 사용하는 RSASSA-PSS(노드 ^6.12.0 또는 >=8.0.0만)
PS512 | SHA-512 해시 알고리즘을 사용하는 RSASSA-PSS(노드 ^6.12.0 또는 >=8.0.0만)
ES256 | P-256 곡선 및 SHA-256 해시 알고리즘을 사용하는 ECDSA
ES384 | P-384 곡선 및 SHA-384 해시 알고리즘을 사용하는 ECDSA
ES512 | P-521 곡선 및 SHA-512 해시 알고리즘을 사용하는 ECDSA
없음 | 디지털 서명 또는 MAC 값이 포함되지 않음

## <a name="refreshing-jwts"></a>JWT 새로 고침

우선 JWT를 자동으로 새로 고치면 시스템에 취약성이 발생하지 않는지 신중하게 생각하는 것이 좋습니다.

라이브러리의 일부로 이 항목을 포함하는 것은 불편합니다. 그러나 [이 예제](https://gist.github.com/ziluvatar/a3feb505c4c0ec37059054537b38fc48)를 살펴보고 이 작업을 수행하는 방법을 보여 줄 수 있습니다.
이 예제 외에도 이 항목에 대한 자세한 정보를 얻기 위한 [문제](https://github.com/auth0/node-jsonwebtoken/issues/122) 및 [끌어오기 요청](https://github.com/auth0/node-jsonwebtoken/pull/172)이 있습니다.

# <a name="todo"></a>TODO

* X.509 인증서 체인이 선택되지 않음

## <a name="issue-reporting"></a> 문제 보고 

버그를 발견했거나 기능 요청이 있는 경우 이 리포지토리 문제 섹션에서 보고하세요. 퍼블릭 GitHub 문제 추적기에서 보안 취약성을 보고하지 마세요. [책임 있는 공개 프로그램](https://auth0.com/whitehat)은 보안 문제를 공개하는 절차를 자세히 설명합니다.

## <a name="author"></a>작성자

[Auth0](https://auth0.com)

## <a name="license"></a>License

이 프로젝트는 MIT 라이선스에 따라 라이선스가 부여됩니다. 자세한 내용은 [LICENSE](LICENSE) 파일을 참조하세요.
