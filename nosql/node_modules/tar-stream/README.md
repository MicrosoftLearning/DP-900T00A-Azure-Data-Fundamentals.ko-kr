---
ms.openlocfilehash: 005b0e7f9a1ee74629126e639e1aeb07226cca3f
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052378"
---
# <a name="tar-stream"></a>tar-stream

tar-stream은 스트리밍 tar 파서 및 생성기이며 다른 것은 없습니다. 이는 streams2이며 스트림을 사용하여 순수하게 작동합니다. 즉, 파일 시스템에 충돌하지 않고 tarball을 쉽게 추출/구문 분석할 수 있습니다.

`.tar.gz`가 있는 경우에도 데이터를 gunzip해야 합니다. 이와 함께 [gunzip-maybe](https://github.com/mafintosh/gunzip-maybe)를 사용하는 것이 좋습니다.

```
npm install tar-stream
```

[![빌드 상태](https://secure.travis-ci.org/mafintosh/tar-stream.png)](http://travis-ci.org/mafintosh/tar-stream)
[![라이선스](https://img.shields.io/badge/license-MIT-blue.svg)](http://opensource.org/licenses/MIT)

## <a name="usage"></a>사용량

tar-stream은 tarball을 생성하는 [pack](https://github.com/mafintosh/tar-stream#packing)과 tarball을 추출하는 [extract](https://github.com/mafintosh/tar-stream#extracting)의 두 가지 스트림을 노출합니다. [기존 tarball을 수정](https://github.com/mafintosh/tar-stream#modifying-existing-tarballs)하려면 둘 다 사용합니다.


pax 확장 헤더에 대한 추가 지원을 통해 USTAR를 구현합니다. 모든 인기 있는 tar 배포판(gnutar, bsdtar 등)과 호환되어야 합니다.

## <a name="related"></a>관련 항목

파일 시스템에서 디렉터리를 압축/압축 해제하려면 이 모듈에 파일 시스템 바인딩을 제공하는 [tar-fs](https://github.com/mafintosh/tar-fs)를 체크 아웃합니다.

## <a name="packing"></a>패킹

팩 스트림을 만들려면 `tar.pack()`을 사용하고 `pack.entry(header, [callback])`을 호출하여 tar 항목을 추가합니다.

``` js
var tar = require('tar-stream')
var pack = tar.pack() // pack is a streams2 stream

// add a file called my-test.txt with the content "Hello World!"
pack.entry({ name: 'my-test.txt' }, 'Hello World!')

// add a file called my-stream-test.txt from a stream
var entry = pack.entry({ name: 'my-stream-test.txt', size: 11 }, function(err) {
  // the stream was added
  // no more entries
  pack.finalize()
})

entry.write('hello')
entry.write(' ')
entry.write('world')
entry.end()

// pipe the pack stream somewhere
pack.pipe(process.stdout)
```

## <a name="extracting"></a>추출

스트림을 추출하려면 `tar.extract()`를 사용하고 `extract.on('entry', (header, stream, next) )`를 수신 대기합니다.

``` js
var extract = tar.extract()

extract.on('entry', function(header, stream, next) {
  // header is the tar header
  // stream is the content body (might be an empty stream)
  // call next when you are done with this entry

  stream.on('end', function() {
    next() // ready for next entry
  })

  stream.resume() // just auto drain the stream
})

extract.on('finish', function() {
  // all entries read
})

pack.pipe(extract)
```

tar 보관 파일은 순차적으로 스트리밍되므로 각 항목의 스트림을 가져올 때 드레이닝 **해야 합니다**. 그렇지 않으면 주 추출 스트림이 백프레셔를 수신하고 읽기를 중지합니다.

## <a name="headers"></a>헤더

`entry`에서 사용하는 헤더 개체는 다음 속성을 포함해야 합니다.
이러한 값의 대부분은 통계에서 파일을 검색하여 찾을 수 있습니다.

``` js
{
  name: 'path/to/this/entry.txt',
  size: 1314,        // entry size. defaults to 0
  mode: 0o644,       // entry mode. defaults to to 0o755 for dirs and 0o644 otherwise
  mtime: new Date(), // last modified date for entry. defaults to now.
  type: 'file',      // type of entry. defaults to file. can be:
                     // file | link | symlink | directory | block-device
                     // character-device | fifo | contiguous-file
  linkname: 'path',  // linked file name
  uid: 0,            // uid of entry owner. defaults to 0
  gid: 0,            // gid of entry owner. defaults to 0
  uname: 'maf',      // uname of entry owner. defaults to null
  gname: 'staff',    // gname of entry owner. defaults to null
  devmajor: 0,       // device major version. defaults to 0
  devminor: 0        // device minor version. defaults to 0
}
```

## <a name="modifying-existing-tarballs"></a>기존 tarball 수정

tar-stream을 사용하면 기존 tarball에서 경로 / 변경 모드 등을 쉽게 다시 작성할 수 있습니다.

``` js
var extract = tar.extract()
var pack = tar.pack()
var path = require('path')

extract.on('entry', function(header, stream, callback) {
  // let's prefix all names with 'tmp'
  header.name = path.join('tmp', header.name)
  // write the new entry to the pack stream
  stream.pipe(pack.entry(header, callback))
})

extract.on('finish', function() {
  // all entries done - lets finalize it
  pack.finalize()
})

// pipe the old tarball to the extractor
oldTarballStream.pipe(extract)

// pipe the new tarball the another stream
pack.pipe(newTarballStream)
```

## <a name="saving-tarball-to-fs"></a>fs에 tarball 저장


``` js
var fs = require('fs')
var tar = require('tar-stream')

var pack = tar.pack() // pack is a streams2 stream
var path = 'YourTarBall.tar'
var yourTarball = fs.createWriteStream(path)

// add a file called YourFile.txt with the content "Hello World!"
pack.entry({name: 'YourFile.txt'}, 'Hello World!', function (err) {
  if (err) throw err
  pack.finalize()
})

// pipe the pack stream to your file
pack.pipe(yourTarball)

yourTarball.on('close', function () {
  console.log(path + ' has been written')
  fs.stat(path, function(err, stats) {
    if (err) throw err
    console.log(stats)
    console.log('Got file info successfully!')
  })
})
```

## <a name="performance"></a>성능

[node-tar와 성능 비교는 tar-fs를 참조하세요.](https://github.com/mafintosh/tar-fs/blob/master/README.md#performance)

# <a name="license"></a>License

MIT
