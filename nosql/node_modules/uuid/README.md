---
ms.openlocfilehash: c6dc9b216d8255c51f2dc575a7c59dce25deff9e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052052"
---
<!--
  -- This file is auto-generated from README_js.md. Changes should be made there.
  -->

# <a name="uuid-cihttpsgithubcomuuidjsuuidactionsqueryworkflow3aci-browserhttpsgithubcomuuidjsuuidactionsqueryworkflow3abrowser"></a>uuid [![CI](https://github.com/uuidjs/uuid/workflows/CI/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ACI) [![Browser](https://github.com/uuidjs/uuid/workflows/Browser/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ABrowser)

[RFC4122](http://www.ietf.org/rfc/rfc4122.txt) UUID를 만드는 경우

- **완료** - RFC4122 버전 1, 3, 4 및 5 UUID 지원
- **플랫폼 간** - 지원:
  - CommonJS, [ECMAScript 모듈](#ecmascript-modules) 및 [CDN 빌드](#cdn-builds)
  - 노드 8, 10, 12, 14
  - Chrome, Safari, Firefox, Edge, IE 11 브라우저
  - Webpack 및 rollup.js 모듈 번들러
  - [React Native/Expo](#react-native--expo)
- **보안** - 암호화가 강력한 임의 값
- **소형** - 제로 종속성, 작은 발자국, “나무 흔들기” 패키징으로 좋은 재생
- **CLI** - [`uuid` 명령줄](#command-line) 유틸리티 포함

**업그레이드 대상`uuid@3.x`?** 코드는 괜찮을 수 있지만 자세한 내용은 [업그레이드 대상`uuid@3.x`](#upgrading-from-uuid3x)을 확인하세요.

## <a name="quickstart"></a>빠른 시작

임의의 UUID를 만들려면...

**1. 설치**

```shell
npm install uuid
```

**2. UUID 만들기**(ES6 모듈 구문)

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // ⇨ '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'
```

... 또는 CommonJS 구문 사용:

```javascript
const { v4: uuidv4 } = require('uuid');
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

타임스탬프 UUID, 네임스페이스 UUID 및 기타 옵션의 경우 ...

## <a name="api-summary"></a>API 요약

|  |  |  |
| --- | --- | --- |
| [`uuid.NIL`](#uuidnil) | nil UUID 문자열(모두 0) | `uuid@8.3`의 새로운 기능 |
| [`uuid.parse()`](#uuidparsestr) | UUID 문자열을 바이트 배열로 변환 | `uuid@8.3`의 새로운 기능 |
| [`uuid.stringify()`](#uuidstringifyarr-offset) | 바이트 배열을 UUID 문자열로 변환 | `uuid@8.3`의 새로운 기능 |
| [`uuid.v1()`](#uuidv1options-buffer-offset) | 버전 1(타임스탬프) UUID 만들기 |  |
| [`uuid.v3()`](#uuidv3name-namespace-buffer-offset) | 버전 3(MD5와 네임스페이스) UUID 만들기 |  |
| [`uuid.v4()`](#uuidv4options-buffer-offset) | 버전 4(임의) UUID 만들기 |  |
| [`uuid.v5()`](#uuidv5name-namespace-buffer-offset) | 버전 5(SHA-1을 사용하는 네임스페이스) UUID 만들기 |  |
| [`uuid.validate()`](#uuidvalidatestr) | 문자열을 테스트하여 유효한 UUID인지 확인 | `uuid@8.3`의 새로운 기능 |
| [`uuid.version()`](#uuidversionstr) | UUID의 RFC 버전 검색 | `uuid@8.3`의 새로운 기능 |

## <a name="api"></a>API

### <a name="uuidnil"></a>uuid.NIL

nil UUID 문자열(모두 0)입니다.

예제:

```javascript
import { NIL as NIL_UUID } from 'uuid';

NIL_UUID; // ⇨ '00000000-0000-0000-0000-000000000000'
```

### <a name="uuidparsestr"></a>uuid.parse(str)

UUID 문자열을 바이트 배열로 변환

|           |                                          |
| --------- | ---------------------------------------- |
| `str`     | 잘못된 UUID `String`                    |
| _returns_ | `Uint8Array[16]`                         |
| _throws_  | `TypeError` `str`이(가) 유효한 URL이 아닌 경우 |

참고: UUID 문자열에서 16진수 쌍의 왼쪽 &Rarr; 오른쪽 순서에 따라 `parse()` 및 `stringify()`에서 사용되는 바이트 배열의 값 순서입니다. 아래 예제에 나와 있습니다.

예:

```javascript
import { parse as uuidParse } from 'uuid';

// Parse a UUID
const bytes = uuidParse('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b');

// Convert to hex strings to show byte order (for documentation purposes)
[...bytes].map((v) => v.toString(16).padStart(2, '0')); // ⇨ 
  // [
  //   '6e', 'c0', 'bd', '7f',
  //   '11', 'c0', '43', 'da',
  //   '97', '5e', '2a', '8a',
  //   'd9', 'eb', 'ae', '0b'
  // ]
```

### <a name="uuidstringifyarr-offset"></a>uuid.stringify(arr[, offset])

바이트 배열을 UUID 문자열로 변환

|                |                                                                              |
| -------------- | ---------------------------------------------------------------------------- |
| `arr`          | `Array`와(과) 같이 0~255 사이의 16개 값(`offset`에서 시작)의 컬렉션과 유사합니다. |
| [`offset` = 0] | `Number` 배열에서 인덱스 시작                                         |
| _returns_      | `String`                                                                     |
| _throws_       | `TypeError` 유효한 UUID 문자열을 생성할 수 없는 경우                       |

참고: UUID 문자열에서 16진수 쌍의 왼쪽 &Rarr; 오른쪽 순서에 따라 `parse()` 및 `stringify()`에서 사용되는 바이트 배열의 값 순서입니다. 아래 예제에 나와 있습니다.

예제:

```javascript
import { stringify as uuidStringify } from 'uuid';

const uuidBytes = [
  0x6e,
  0xc0,
  0xbd,
  0x7f,
  0x11,
  0xc0,
  0x43,
  0xda,
  0x97,
  0x5e,
  0x2a,
  0x8a,
  0xd9,
  0xeb,
  0xae,
  0x0b,
];

uuidStringify(uuidBytes); // ⇨ '6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'
```

### <a name="uuidv1options-buffer-offset"></a>uuid.v1([options[, buffer[, offset]]])

RFC 버전 1(타임스탬프) UUID 만들기

|  |  |
| --- | --- |
| [`options`] | 다음 속성 중 하나 이상이 있는 `Object`: |
| [`options.node` ] | RFC “노드” 필드를 `Array[6]` 바이트 값으로(4.1.6당) |
| [`options.clockseq`] | RFC “클록 시퀀스”는 `Number` 0에서 0x3fff 사이 |
| [`options.msecs`] | RFC “타임스탬프” 필드(`Number` 밀리초, unix epoch) |
| [`options.nsecs`] | RFC “타임스탬프” 필드(`msecs`에 추가할 `Number` nanseconds의 경우 0-10,000이어야 함) |
| [`options.random`] | 16개 임의 바이트의 `Array`(0-255) |
| [`options.rng`] | `options.random`에 대한 대안으로, 16개 임의 바이트(0-255)의 `Array`반환하는 `Function` |
| [`buffer`] | `Array \| Buffer` 지정된 경우 uuid는 `offset`에서 바이트 형식으로 작성됩니다. |
| [`offset` = 0] | `Number` `buffer`에서 UUID 바이트 쓰기를 시작하는 인덱스 |
| _returns_ | `buffer`이(가) 지정되지 않으면 `String`이고 그렇지 않으면 `buffer`반환됩니다. |
| _throws_ | 10M UUID/초 이상이 요청되면 `Error` |

참고: 기본 [노드 ID](https://tools.ietf.org/html/rfc4122#section-4.1.6) (UUID의 마지막 12자리)는 프로세스 시작 시 임의로 한 번 생성된 다음 프로세스 기간 동안 변경되지 않은 상태로 유지됩니다.

참고: `options.random` 및 `options.rng`은(는) 내부 `node` 및 `clockseq` 필드를 초기화하기 위해 전달될 수 있는 `v1()`의 맨 처음 호출에서만 의미가 있습니다.

예:

```javascript
import { v1 as uuidv1 } from 'uuid';

uuidv1(); // ⇨ '2c5ea4c0-4067-11e9-8bad-9b1deb4d3b7d'
```

`options`을(를) 사용하는 예제:

```javascript
import { v1 as uuidv1 } from 'uuid';

const v1options = {
  node: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab],
  clockseq: 0x1234,
  msecs: new Date('2011-11-01').getTime(),
  nsecs: 5678,
};
uuidv1(v1options); // ⇨ '710b962e-041c-11e1-9234-0123456789ab'
```

### <a name="uuidv3name-namespace-buffer-offset"></a>uuid.v3(name, namespace[, buffer[, offset]])

RFC 버전 3(MD5와 네임스페이스) UUID 만들기

API는 `v5()`와(과) 동일하지만 대신 “v3”를 사용합니다.

&#x26a0;&#xfe0f; 참고: RFC에 따라 “_이전 버전과의 호환성이 문제가 되지 않는 경우 SHA-1 [버전 5]가 선호됩니다_.”

### <a name="uuidv4options-buffer-offset"></a>uuid.v4([options[, buffer[, offset]]])

RFC 버전 4(임의) UUID 만들기

|  |  |
| --- | --- |
| [`options`] | 다음 속성 중 하나 이상이 있는 `Object`: |
| [`options.random`] | 16개 임의 바이트의 `Array`(0-255) |
| [`options.rng`] | `options.random`에 대한 대안으로, 16개 임의 바이트(0-255)의 `Array`반환하는 `Function` |
| [`buffer`] | `Array \| Buffer` 지정된 경우 uuid는 `offset`에서 바이트 형식으로 작성됩니다. |
| [`offset` = 0] | `Number` `buffer`에서 UUID 바이트 쓰기를 시작하는 인덱스 |
| _returns_ | `buffer`이(가) 지정되지 않으면 `String`이고 그렇지 않으면 `buffer`반환됩니다. |

예제:

```javascript
import { v4 as uuidv4 } from 'uuid';

uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

미리 정의된 `random` 값을 사용하는 예제:

```javascript
import { v4 as uuidv4 } from 'uuid';

const v4options = {
  random: [
    0x10,
    0x91,
    0x56,
    0xbe,
    0xc4,
    0xfb,
    0xc1,
    0xea,
    0x71,
    0xb4,
    0xef,
    0xe1,
    0x67,
    0x1c,
    0x58,
    0x36,
  ],
};
uuidv4(v4options); // ⇨ '109156be-c4fb-41ea-b1b4-efe1671c5836'
```

### <a name="uuidv5name-namespace-buffer-offset"></a>uuid.v5(name, namespace[, buffer[, offset]])

RFC 버전 5(SHA-1을 사용하는 네임스페이스) UUID 만들기

|  |  |
| --- | --- |
| `name` | `String \| Array` |
| `namespace` | `String \| Array[16]` 네임스페이스 UUID |
| [`buffer`] | `Array \| Buffer` 지정된 경우 uuid는 `offset`에서 바이트 형식으로 작성됩니다. |
| [`offset` = 0] | `Number` `buffer`에서 UUID 바이트 쓰기를 시작하는 인덱스 |
| _returns_ | `buffer`이(가) 지정되지 않으면 `String`이고 그렇지 않으면 `buffer`반환됩니다. |

참고: RFC `DNS` 및 `URL` 네임스페이스는 다음과 같이 `v5.DNS` 및 `v5.URL`을(를) 사용할 수 있습니다.

사용자 지정 네임스페이스를 사용하는 예제:

```javascript
import { v5 as uuidv5 } from 'uuid';

// Define a custom namespace.  Readers, create your own using something like
// https://www.uuidgenerator.net/
const MY_NAMESPACE = '1b671a64-40d5-491e-99b0-da01ff1f3341';

uuidv5('Hello, World!', MY_NAMESPACE); // ⇨ '630eb68f-e0fa-5ecc-887a-7c7a62614681'
```

RFC `URL` 네임스페이스를 사용하는 예제:

```javascript
import { v5 as uuidv5 } from 'uuid';

uuidv5('https://www.w3.org/', uuidv5.URL); // ⇨ 'c106a26a-21bb-5538-8bf2-57095d1976c1'
```

### <a name="uuidvalidatestr"></a>uuid.validate(str)

문자열을 테스트하여 유효한 UUID인지 확인

|           |                                                     |
| --------- | --------------------------------------------------- |
| `str`     | 유효성을 검사할 `String`                                |
| _returns_ | 문자열이 유효한 UUID이면 `true`이고 그렇지 않으면 `false` |

예제:

```javascript
import { validate as uuidValidate } from 'uuid';

uuidValidate('not a UUID'); // ⇨ false
uuidValidate('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // ⇨ true
```

`validate` 및 `version`을(를) 함께 사용하면 버전별 유효성 검사를 수행할 수 있습니다(예: v4 UID에 대해서만 유효성 검사).

```javascript
import { version as uuidVersion } from 'uuid';
import { validate as uuidValidate } from 'uuid';

function uuidValidateV4(uuid) {
  return uuidValidate(uuid) && uuidVersion(uuid) === 4;
}

const v1Uuid = 'd9428888-122b-11e1-b85c-61cd3cbb3210';
const v4Uuid = '109156be-c4fb-41ea-b1b4-efe1671c5836';

uuidValidateV4(v4Uuid); // ⇨ true
uuidValidateV4(v1Uuid); // ⇨ false
```

### <a name="uuidversionstr"></a>uuid.version(str)

UUID의 RFC 버전 검색

|           |                                          |
| --------- | ---------------------------------------- |
| `str`     | 잘못된 UUID `String`                    |
| _returns_ | `Number` UUID의 RFC 버전     |
| _throws_  | `TypeError` `str`이(가) 유효한 URL이 아닌 경우 |

예제:

```javascript
import { version as uuidVersion } from 'uuid';

uuidVersion('45637ec4-c85f-11ea-87d0-0242ac130003'); // ⇨ 1
uuidVersion('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // ⇨ 4
```

## <a name="command-line"></a>명령줄

`uuid`를 사용하여 명령줄에서 UUID를 생성할 수 있습니다.

```shell
$ uuid
ddeb27fb-d9a0-4624-be4d-4615062daed4
```

기본값은 버전 4 UUIDS를 생성하는 것이지만 다른 버전도 지원됩니다. 자세한 내용은 `uuid --help`을 참조하세요.

```shell
$ uuid --help

Usage:
  uuid
  uuid v1
  uuid v3 <name> <namespace uuid>
  uuid v4
  uuid v5 <name> <namespace uuid>
  uuid --help

Note: <namespace uuid> may be "URL" or "DNS" to use the corresponding UUIDs
defined by RFC4122
```

## <a name="ecmascript-modules"></a>ECMAScript 모듈

이 라이브러리에는 ESM을 지원하는 Node.js 버전([예제](./examples/node-esmodules/))을 지원하는 ESM([ECMAScript 모듈](https://www.ecma-international.org/ecma-262/6.0/#sec-modules))뿐만 아니라 [rollup.js](https://rollupjs.org/guide/en/#tree-shaking)([예제](./examples/browser-rollup/)) 및 [webpack](https://webpack.js.org/guides/tree-shaking/)([예제](./examples/browser-webpack/))과 같은 번들러(Node.js 및 브라우저 환경 모두 대상으로 지정)가 함께 제공됩니다.

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

예제를 실행하려면 먼저 모듈 루트에서 이 라이브러리의 dist 빌드를 만들어야 합니다.

```shell
npm run build
```

## <a name="cdn-builds"></a>CDN 빌드

### <a name="ecmascript-modules"></a>ECMAScript 모듈

[ECMAScript 모듈 로드를 지원](https://caniuse.com/#feat=es6-module)하는 최신 브라우저에 이 모듈을 직접 로드하려면 [jspm](https://jspm.org/)을 사용하면 됩니다.

```html
<script type="module">
  import { v4 as uuidv4 } from 'https://jspm.dev/uuid';
  console.log(uuidv4()); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
</script>
```

### <a name="umd"></a>UMD

이 모듈을 이전 브라우저에 직접 로드하려면 다음 CDN 중 하나에서 [UMD(유니버설 모듈 정의)](https://github.com/umdjs/umd) 빌드를 사용할 수 있습니다.

**[UNPKG](https://unpkg.com/uuid@latest/dist/umd/)** 사용:

```html
<script src="https://unpkg.com/uuid@latest/dist/umd/uuidv4.min.js"></script>
```

**[jsDelivr](https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/)** 사용:

```html
<script src="https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/uuidv4.min.js"></script>
```

**[cdnjs](https://cdnjs.com/libraries/uuid)** 사용:

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.1.0/uuidv4.min.js"></script>
```

이러한 CDN은 모두 동일한 [`uuidv4()`](#uuidv4options-buffer-offset) 메서드를 제공합니다.

```html
<script>
  uuidv4(); // ⇨ '55af1e37-0734-46d8-b070-a1e42e4fc392'
</script>
```

다른 알고리즘([`uuidv1()`](#uuidv1options-buffer-offset), [`uuidv3()`](#uuidv3name-namespace-buffer-offset) 및 [`uuidv5()`](#uuidv5name-namespace-buffer-offset))에 대한 메서드는 `uuidv1.min.js`, `uuidv3.min.js` 및 `uuidv5.min.js` 파일에서 각각 사용할 수 있습니다.

## <a name="getrandomvalues-not-supported"></a>"getRandomValues() not supported"

이 오류는 표준 [`crypto.getRandomValues()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues) API가 지원되지 않는 환경에서 발생합니다. 적절한 폴리필을 추가하여 이 문제를 해결할 수 있습니다.

### <a name="react-native--expo"></a>React Native/Expo

1. [`react-native-get-random-values`](https://github.com/LinusU/react-native-get-random-values#readme) 설치
1. `uuid` _전에_ 가져옵니다. `uuid`은(는) 다른 가져오기의 전이적 종속성으로 표시될 수도 있으므로 `react-native-get-random-values`은(는) 진입점에서 가장 먼저 가져오는 것이 가장 안전합니다.

```javascript
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';
```

참고: Expo를 사용하는 경우 최소한 `react-native-get-random-values@1.5.0` 및 `expo@39.0.0`을 사용 중이어야 합니다.

### <a name="web-workers--service-workers-edge--18"></a>웹 작업자/서비스 작업자(Edge <= 18)

[Edge <= 18에서 웹 암호화는 웹 작업자 또는 서비스 작업자에서 지원되지 않으며](https://caniuse.com/#feat=cryptography) 폴리필을 인식하지 못합니다(찾을 경우 알려주세요).

## <a name="upgrading-from-uuid7x"></a>업그레이드 대상 `uuid@7.x`

### <a name="only-named-exports-supported-when-using-with-nodejs-esm"></a>Node.js ESM과 함께 사용할 때 지원되는 명명된 내보내기만

`uuid@7.x`에서는 Node.js 대한 네이티브 ECMAScript 모듈(ESM) 지원이 제공되지 않았습니다. Node.js ESM에서 가져온 결과 기본 내보내기를 사용하여 CommonJS 원본을 가져왔습니다. 이 라이브러리는 이제 진정한 Node.js ESM 지원과 함께 제공되며 명명된 내보내기만 제공합니다.

대신 다음을 수행합니다.

```javascript
import uuid from 'uuid';
uuid.v4();
```

이제 명명된 내보내기를 사용해야 합니다.

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4();
```

### <a name="deep-requires-no-longer-supported"></a>딥 요구 사항은 더 이상 지원되지 않음

`require('uuid/v4')`[에서 더 이상 사용되지 않는`uuid@7.x`](#deep-requires-now-deprecated) 와(과) 같은 딥 요구 사항은 더 이상 지원되지 않습니다.

## <a name="upgrading-from-uuid3x"></a>업그레이드 대상 `uuid@3.x`

“_어떻게 된 건가요?`uuid@4.x` - `uuid@6.x`_ ”

RFC [ 버전 4](#uuidv4options-buffer-offset) 및 [버전 5](#uuidv5name-namespace-buffer-offset) UUID 및 가능한 [버전 6](http://gh.peabody.io/uuidv6/)과의 혼동을 방지하기 위해 이 모듈의 릴리스 4부터 6까지 건너뛰었습니다.

### <a name="deep-requires-now-deprecated"></a>딥 요구 사항은 더 이상 사용되지 않음

`uuid@3.x`에서는 브라우저 빌드의 번들 크기를 최소화하기 위해 심층적인 사용을 권장했습니다.

```javascript
const uuidv4 = require('uuid/v4'); // <== NOW DEPRECATED!
uuidv4();
```

`uuid@7.x`부터 이 라이브러리는 WEBpack 및 Rollup과 같은 패키징에서 “트리 흔들기”를 수행하여 데드 코드를 제거할 수 있는 ECMAScript 모듈 빌드를 제공합니다. 대신 `import` 구문을 사용합니다.

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4();
```

... 또는 CommonJS의 경우:

```javascript
const { v4: uuidv4 } = require('uuid');
uuidv4();
```

### <a name="default-export-removed"></a>기본 내보내기 제거됨

`uuid@3.x`에서는 버전 4 UUID 메서드를 기본 내보내기로 내보냅니다.

```javascript
const uuid = require('uuid'); // <== REMOVED!
```

이 사용 패턴은 이미 `uuid@3.x`에서 권장되지 않았으며 `uuid@7.x`에서 제거되었습니다.

----
[![RunMD 로고](http://i.imgur.com/h0FVyzU.png)](https://github.com/broofa/runmd)에 의해 [README_js.md](README_js.md)에서 생성된 Markdown