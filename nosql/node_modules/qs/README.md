---
ms.openlocfilehash: 334cc21b44dad92ee91fd1f8a2aaf91f242cea2e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052754"
---
# <a name="qs-supversion-badge21sup"></a>qs <sup>[![버전 배지][2]][1]</sup>

[![빌드 상태][3]][4]
[![종속성 상태][5]][6]
[![개발 종속성 상태][7]][8]
[![라이선스][license-image]][license-url]
[![다운로드][downloads-image]][downloads-url]

[![npm 배지][11]][1]

일부 보안이 추가된 쿼리 문자열 구문 분석 및 문자열 변환 라이브러리입니다.

잠재 고객 유지 관리자: [Jordan Harband](https://github.com/ljharb)

**qs** 모듈은 원래 [TJ Holowaychuk](https://github.com/visionmedia/node-querystring)에 의해 만들어지고 유지 관리되었습니다.

## <a name="usage"></a>사용량

```javascript
var qs = require('qs');
var assert = require('assert');

var obj = qs.parse('a=c');
assert.deepEqual(obj, { a: 'c' });

var str = qs.stringify(obj);
assert.equal(str, 'a=c');
```

### <a name="parsing-objects"></a>개체 구문 분석

[](#preventEval)
```javascript
qs.parse(string, [options]);
```

**qs** 를 사용하면 하위 키 이름을 대괄호 `[]`로 묶어 쿼리 문자열 내에 중첩된 개체를 만들 수 있습니다.
예를 들어 문자열 `'foo[bar]=baz'`는 다음으로 변환됩니다.

```javascript
assert.deepEqual(qs.parse('foo[bar]=baz'), {
    foo: {
        bar: 'baz'
    }
});
```

`plainObjects` 옵션을 사용하는 경우 구문 분석된 값은 null 개체로 반환되고, `Object.create(null)`을 통해 생성되므로 프로토타입 메서드가 존재하지 않으며 사용자가 해당 이름을 원하는 값으로 설정할 수 있습니다.

```javascript
var nullObject = qs.parse('a[hasOwnProperty]=b', { plainObjects: true });
assert.deepEqual(nullObject, { a: { hasOwnProperty: 'b' } });
```

기본적으로 개체 프로토타입의 속성을 덮어쓰는 매개 변수는 위에서 설명한 대로 `plainObjects`를 사용하거나 사용자 입력이 해당 속성을 덮어쓸 수 있도록 `allowPrototypes`를 `true`로 설정하는 필드의 데이터를 유지하려는 경우 무시됩니다. 경고 일반적으로 덮어쓴 속성을 사용하려고 할 때 문제가 발생할 수 있으므로 이 옵션을 사용하도록 설정하는 것은 좋지 않습니다. 항상 이 옵션에 주의하세요.

```javascript
var protoObject = qs.parse('a[hasOwnProperty]=b', { allowPrototypes: true });
assert.deepEqual(protoObject, { a: { hasOwnProperty: 'b' } });
```

URI로 인코딩된 문자열도 작동합니다.

```javascript
assert.deepEqual(qs.parse('a%5Bb%5D=c'), {
    a: { b: 'c' }
});
```

`'foo[bar][baz]=foobarbaz'`와 같은 개체를 중첩할 수도 있습니다.

```javascript
assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), {
    foo: {
        bar: {
            baz: 'foobarbaz'
        }
    }
});
```

기본적으로 개체를 중첩할 때 **qs** 는 최대 5개의 자식 깊이까지만 구문 분석합니다. 즉, `'a[b][c][d][e][f][g][h][i]=j'`와 같은 문자열을 구문 분석하려고 하면 결과 개체는 다음과 같습니다.

```javascript
var expected = {
    a: {
        b: {
            c: {
                d: {
                    e: {
                        f: {
                            '[g][h][i]': 'j'
                        }
                    }
                }
            }
        }
    }
};
var string = 'a[b][c][d][e][f][g][h][i]=j';
assert.deepEqual(qs.parse(string), expected);
```

이 깊이는 `depth` 옵션을 `qs.parse(string, [options])`에 전달하여 재정의할 수 있습니다.

```javascript
var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });
assert.deepEqual(deep, { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } });
```

깊이 제한은 **qs** 가 사용자 입력을 구문 분석하는 데 사용될 때 남용을 완화하는 데 도움이 되며, 합리적으로 적은 수로 유지하는 것이 좋습니다.

비슷한 이유로 기본적으로 **qs** 는 최대 1,000개의 매개 변수만 구문 분석합니다. 이는 `parameterLimit` 옵션을 전달하여 재정의할 수 있습니다.

```javascript
var limited = qs.parse('a=b&c=d', { parameterLimit: 1 });
assert.deepEqual(limited, { a: 'b' });
```

선행 물음표를 무시하려면 `ignoreQueryPrefix`를 사용합니다.

```javascript
var prefixed = qs.parse('?a=b&c=d', { ignoreQueryPrefix: true });
assert.deepEqual(prefixed, { a: 'b', c: 'd' });
```

선택적 구분 기호를 전달할 수도 있습니다.

```javascript
var delimited = qs.parse('a=b;c=d', { delimiter: ';' });
assert.deepEqual(delimited, { a: 'b', c: 'd' });
```

구분 기호도 정규식일 수 있습니다.

```javascript
var regexed = qs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });
assert.deepEqual(regexed, { a: 'b', c: 'd', e: 'f' });
```

옵션 `allowDots`는 점 표기법을 사용하도록 설정하는 데 사용할 수 있습니다.

```javascript
var withDots = qs.parse('a.b=c', { allowDots: true });
assert.deepEqual(withDots, { a: { b: 'c' } });
```

레거시 브라우저 또는 서비스를 처리해야 하는 경우 백분율로 인코딩된 옥텟을 iso-8859-1로 디코딩하는 기능도 지원됩니다.

```javascript
var oldCharset = qs.parse('a=%A7', { charset: 'iso-8859-1' });
assert.deepEqual(oldCharset, { a: '§' });
```

일부 서비스는 양식에 초기 `utf8=✓` 값을 추가하여 이전 Internet Explorer 버전이 양식을 utf-8로 제출할 가능성이 더 높습니다. 또한 서버는 확인 표시 문자의 잘못된 인코딩에 대해 값을 확인하고 쿼리 문자열 또는 `application/x-www-form-urlencoded` 본문이 utf-8로 전송되지 않았음을 감지할 수 있습니다. 예를 들어 양식에 `accept-charset` 매개 변수가 있거나 포함된 페이지에 다른 문자 집합이 있는 경우입니다.

**qs** 는 `charsetSentinel` 옵션을 통해 이 메커니즘을 지원합니다.
지정된 경우 `utf8` 매개 변수는 반환된 개체에서 생략됩니다. 확인 표시가 인코딩되는 방법에 따라 `iso-8859-1`/`utf-8` 모드로 전환하는 데 사용됩니다.

**중요**: `charset` 옵션과 `charsetSentinel` 옵션을 모두 지정하는 경우 요청에 실제 문자 집합을 추론할 수 있는 `utf8` 매개 변수가 포함되어 있으면 `charset`가 재정의됩니다. 그런 의미에서 `charset`는 신뢰할 수 있는 문자 집합이 아닌 기본 문자 집합으로 동작합니다.

```javascript
var detectedAsUtf8 = qs.parse('utf8=%E2%9C%93&a=%C3%B8', {
    charset: 'iso-8859-1',
    charsetSentinel: true
});
assert.deepEqual(detectedAsUtf8, { a: 'ø' });

// Browsers encode the checkmark as &#10003; when submitting as iso-8859-1:
var detectedAsIso8859_1 = qs.parse('utf8=%26%2310003%3B&a=%F8', {
    charset: 'utf-8',
    charsetSentinel: true
});
assert.deepEqual(detectedAsIso8859_1, { a: 'ø' });
```

`&#...;` 구문을 실제 문자로 디코딩하려는 경우 `interpretNumericEntities` 옵션도 지정할 수 있습니다.

```javascript
var detectedAsIso8859_1 = qs.parse('a=%26%239786%3B', {
    charset: 'iso-8859-1',
    interpretNumericEntities: true
});
assert.deepEqual(detectedAsIso8859_1, { a: '☺' });
```

또한 문자 집합이 `charsetSentinel` 모드에서 검색된 경우에도 작동합니다.

### <a name="parsing-arrays"></a>배열 구문 분석

**qs** 는 유사한 `[]` 표기법을 사용하여 배열을 구문 분석할 수도 있습니다.

```javascript
var withArray = qs.parse('a[]=b&a[]=c');
assert.deepEqual(withArray, { a: ['b', 'c'] });
```

인덱스도 지정할 수 있습니다.

```javascript
var withIndexes = qs.parse('a[1]=c&a[0]=b');
assert.deepEqual(withIndexes, { a: ['b', 'c'] });
```

배열의 인덱스와 개체의 키 간의 유일한 차이점은 대괄호 사이의 값이 배열을 만들려면 숫자여야 한다는 것입니다. 특정 인덱스를 사용하여 배열을 만들 때 **qs** 는 스파스 배열을 순서를 유지하는 기존 값으로만 압축합니다.

```javascript
var noSparse = qs.parse('a[1]=b&a[15]=c');
assert.deepEqual(noSparse, { a: ['b', 'c'] });
```

스파스 배열을 구문 분석하는 `allowSparse` 옵션을 사용할 수도 있습니다.

```javascript
var sparseArray = qs.parse('a[1]=2&a[3]=5', { allowSparse: true });
assert.deepEqual(sparseArray, { a: [, '2', , '5'] });
```

빈 문자열도 값이며 유지됩니다.

```javascript
var withEmptyString = qs.parse('a[]=&a[]=b');
assert.deepEqual(withEmptyString, { a: ['', 'b'] });

var withIndexedEmptyString = qs.parse('a[0]=b&a[1]=&a[2]=c');
assert.deepEqual(withIndexedEmptyString, { a: ['b', '', 'c'] });
```

또한 **qs** 는 배열의 인덱스 지정을 최대 인덱스 `20`으로 제한합니다. 인덱스가 `20`보다 큰 배열 멤버는 대신 인덱스가 키인 개체로 변환됩니다. 예를 들어 이것은 누군가가 `a[999999999]`를 보낸 경우를 처리하는 데 필요하며 이 거대한 배열을 반복하는 데 상당한 시간이 걸립니다.

```javascript
var withMaxIndex = qs.parse('a[100]=b');
assert.deepEqual(withMaxIndex, { a: { '100': 'b' } });
```

이 제한은 `arrayLimit` 옵션을 전달하여 재정의할 수 있습니다.

```javascript
var withArrayLimit = qs.parse('a[1]=b', { arrayLimit: 0 });
assert.deepEqual(withArrayLimit, { a: { '1': 'b' } });
```

배열 구문 분석을 완전히 사용하도록 않도록 설정하려면 `parseArrays`를 `false`로 설정합니다.

```javascript
var noParsingArrays = qs.parse('a[]=b', { parseArrays: false });
assert.deepEqual(noParsingArrays, { a: { '0': 'b' } });
```

표기법을 혼합하는 경우 **qs** 는 두 항목을 하나의 개체로 병합합니다.

```javascript
var mixedNotation = qs.parse('a[0]=b&a[b]=c');
assert.deepEqual(mixedNotation, { a: { '0': 'b', b: 'c' } });
```

개체 배열을 생성할 수도 있습니다.

```javascript
var arraysOfObjects = qs.parse('a[][b]=c');
assert.deepEqual(arraysOfObjects, { a: [{ b: 'c' }] });
```

어떤 사람들은 쉼표로 배열을 조인하는데, **qs** 는 이를 구문 분석할 수 있습니다.
```javascript
var arraysOfObjects = qs.parse('a=b,c', { comma: true })
assert.deepEqual(arraysOfObjects, { a: ['b', 'c'] })
```
( _`a={b:1},{c:d}`_ 과 같은 중첩된 객체는 변환할 수 없습니다.)

### <a name="stringifying"></a>문자열 변환

[](#preventEval)
```javascript
qs.stringify(object, [options]);
```

문자열 변환할 때 기본적으로 URI는 **qs** 로 출력을 인코딩합니다. 개체는 예상대로 문자열 변환됩니다.

```javascript
assert.equal(qs.stringify({ a: 'b' }), 'a=b');
assert.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');
```

이 인코딩은 `encode` 옵션을 `false`로 설정하여 사용하지 않도록 설정할 수 있습니다.

```javascript
var unencoded = qs.stringify({ a: { b: 'c' } }, { encode: false });
assert.equal(unencoded, 'a[b]=c');
```

`encodeValuesOnly` 옵션을 `true`로 설정하여 키에 대한 인코딩을 사용하지 않도록 설정할 수 있습니다.
```javascript
var encodedValues = qs.stringify(
    { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
    { encodeValuesOnly: true }
);
assert.equal(encodedValues,'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h');
```

이 인코딩을 `encoder` 옵션으로 설정된 사용자 지정 인코딩 메서드로 바꿀 수도 있습니다.

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str) {
    // Passed in values `a`, `b`, `c`
    return // Return encoded string
}})
```

_(참고: `encode`가 `false`인 경우 `encoder` 옵션은 적용되지 않습니다.)_

`encoder`와 유사하게 속성 및 값의 디코딩을 재정의하는 `parse`에 대한 `decoder` 옵션이 있습니다.

```javascript
var decoded = qs.parse('x=z', { decoder: function (str) {
    // Passed in values `x`, `z`
    return // Return decoded string
}})
```

인코더에 제공된 형식 인수를 사용하여 다른 논리를 사용하여 키와 값을 인코딩할 수 있습니다.

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str, defaultEncoder, charset, type) {
    if (type === 'key') {
        return // Encoded key
    } else if (type === 'value') {
        return // Encoded value
    }
}})
```

형식 인수도 디코더에 제공됩니다.

```javascript
var decoded = qs.parse('x=z', { decoder: function (str, defaultDecoder, charset, type) {
    if (type === 'key') {
        return // Decoded key
    } else if (type === 'value') {
        return // Decoded value
    }
}})
```

이 시점 이후의 예제는 출력이 명확성을 위해 인코딩된 URI가 아닌 것처럼 표시됩니다. 이러한 경우 반환 값은 실제 사용 중에 URI로 인코딩됩니다.

배열이 문자열 변환되면 기본적으로 명시적 인덱스가 제공됩니다.

```javascript
qs.stringify({ a: ['b', 'c', 'd'] });
// 'a[0]=b&a[1]=c&a[2]=d'
```

`indices` 옵션을 `false`로 설정하여 이 옵션을 재정의 할 수 있습니다.

```javascript
qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });
// 'a=b&a=c&a=d'
```

`arrayFormat` 옵션을 사용하여 출력 배열의 형식을 지정할 수 있습니다.

```javascript
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })
// 'a[0]=b&a[1]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })
// 'a[]=b&a[]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })
// 'a=b&a=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'comma' })
// 'a=b,c'
```

개체가 문자열 변환되면 기본적으로 대괄호 표기법을 사용합니다.

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } });
// 'a[b][c]=d&a[b][e]=f'
```

`allowDots` 옵션을 `true`로 설정하여 점 표기법을 사용하도록 이를 재정의할 수 있습니다.

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } }, { allowDots: true });
// 'a.b.c=d&a.b.e=f'
```

빈 문자열과 null 값은 값을 생략하지만 등호(=)는 그대로 유지됩니다.

```javascript
assert.equal(qs.stringify({ a: '' }), 'a=');
```

값이 없는 키(예: 빈 개체 또는 배열)는 아무 것도 반환하지 않습니다.

```javascript
assert.equal(qs.stringify({ a: [] }), '');
assert.equal(qs.stringify({ a: {} }), '');
assert.equal(qs.stringify({ a: [{}] }), '');
assert.equal(qs.stringify({ a: { b: []} }), '');
assert.equal(qs.stringify({ a: { b: {}} }), '');
```

`undefined`로 설정되는 속성은 완전히 생략됩니다.

```javascript
assert.equal(qs.stringify({ a: null, b: undefined }), 'a=');
```

필요에 따라 쿼리 문자열 앞에 물음표가 추가될 수 있습니다.

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { addQueryPrefix: true }), '?a=b&c=d');
```

구분 기호는 문자열 변환으로 재정의될 수도 있습니다.

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' }), 'a=b;c=d');
```

`Date` 개체의 직렬화만 재정의하려는 경우 `serializeDate` 옵션을 제공할 수 있습니다.

```javascript
var date = new Date(7);
assert.equal(qs.stringify({ a: date }), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));
assert.equal(
    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),
    'a=7'
);
```

`sort` 옵션을 사용하여 매개 변수 키의 순서에 영향을 줄 수 있습니다.

```javascript
function alphabeticalSort(a, b) {
    return a.localeCompare(b);
}
assert.equal(qs.stringify({ a: 'c', z: 'y', b : 'f' }, { sort: alphabeticalSort }), 'a=c&b=f&z=y');
```

마지막으로, `filter` 옵션을 사용하여 문자열 변환된 출력에 포함될 키를 제한할 수 있습니다.
함수를 전달하면 각 키가 교체 값을 얻기 위해 호출됩니다. 그렇지 않으면 배열을 전달하는 경우 문자열 변환에 대한 속성 및 배열 인덱스를 선택하는 데 사용됩니다.

```javascript
function filterFunc(prefix, value) {
    if (prefix == 'b') {
        // Return an `undefined` value to omit a property.
        return;
    }
    if (prefix == 'e[f]') {
        return value.getTime();
    }
    if (prefix == 'e[g][0]') {
        return value * 2;
    }
    return value;
}
qs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc });
// 'a=b&c=d&e[f]=123&e[g][0]=4'
qs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] });
// 'a=b&e=f'
qs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] });
// 'a[0]=b&a[2]=d'
```

### <a name="handling-of-null-values"></a>`null` 값 처리

기본적으로 `null` 값은 빈 문자열처럼 처리됩니다.

```javascript
var withNull = qs.stringify({ a: null, b: '' });
assert.equal(withNull, 'a=&b=');
```

구문 분석은 등호가 있는 매개 변수와 없는 매개 변수를 구분하지 않습니다. 둘 다 빈 문자열로 변환됩니다.

```javascript
var equalsInsensitive = qs.parse('a&b=');
assert.deepEqual(equalsInsensitive, { a: '', b: '' });
```

`null` 값과 빈 문자열을 구분하려면 `strictNullHandling` 플래그를 사용합니다. 결과 문자열에서 `null` 값에는 `=` 기호가 없습니다.

```javascript
var strictNull = qs.stringify({ a: null, b: '' }, { strictNullHandling: true });
assert.equal(strictNull, 'a&b=');
```

`strictNullHandling` 플래그를 사용하기 위해 `=` 없이 값을 다시 `null`로 구문 분석하려면 다음을 수행합니다.

```javascript
var parsedStrictNull = qs.parse('a&b=', { strictNullHandling: true });
assert.deepEqual(parsedStrictNull, { a: null, b: '' });
```

`null` 값이 있는 렌더링 키를 완전히 건너뛰려면 `skipNulls` 플래그를 사용합니다.

```javascript
var nullsSkipped = qs.stringify({ a: 'b', c: null}, { skipNulls: true });
assert.equal(nullsSkipped, 'a=b');
```

레거시 시스템과 통신하는 경우 `charset` 옵션을 사용하여 `iso-8859-1`로 전환할 수 있습니다.

```javascript
var iso = qs.stringify({ æ: 'æ' }, { charset: 'iso-8859-1' });
assert.equal(iso, '%E6=%E6');
```

`iso-8859-1`에 존재하지 않는 문자는 브라우저가 수행하는 것과 유사하게 숫자 엔티티로 변환됩니다.

```javascript
var numeric = qs.stringify({ a: '☺' }, { charset: 'iso-8859-1' });
assert.equal(numeric, 'a=%26%239786%3B');
```

양식을 제출할 때 Ruby on Rails 및 다른 사용자가 수행하는 것과 유사한 확인 표시인 경우 적절한 인코딩이 있는 `utf8=✓` 매개 변수를 포함하여 문자를 알리는 `charsetSentinel` 옵션을 사용할 수 있습니다.

```javascript
var sentinel = qs.stringify({ a: '☺' }, { charsetSentinel: true });
assert.equal(sentinel, 'utf8=%E2%9C%93&a=%E2%98%BA');

var isoSentinel = qs.stringify({ a: 'æ' }, { charsetSentinel: true, charset: 'iso-8859-1' });
assert.equal(isoSentinel, 'utf8=%26%2310003%3B&a=%E6');
```

### <a name="dealing-with-special-character-sets"></a>특수 문자 집합 처리

기본적으로 `utf-8`에서 문자의 인코딩 및 디코딩이 수행되며 `charset` 매개 변수를 통해 `iso-8859-1` 지원도 빌드됩니다.

쿼리 문자열을 다른 문자 집합(예: [Shift JIS](https://en.wikipedia.org/wiki/Shift_JIS))으로 인코딩하려는 경우 [`qs-iconv`](https://github.com/martinheidegger/qs-iconv) 라이브러리를 사용할 수 있습니다.

```javascript
var encoder = require('qs-iconv/encoder')('shift_jis');
var shiftJISEncoded = qs.stringify({ a: 'こんにちは！' }, { encoder: encoder });
assert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');
```

이는 쿼리 문자열의 디코딩에도 작동합니다.

```javascript
var decoder = require('qs-iconv/decoder')('shift_jis');
var obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', { decoder: decoder });
assert.deepEqual(obj, { a: 'こんにちは！' });
```

### <a name="rfc-3986-and-rfc-1738-space-encoding"></a>RFC 3986 및 RFC 1738 공간 인코딩

RFC3986은 기본 옵션으로 사용되고 ‘’을 이전 버전과 호환되는 *%20* 으로 인코딩합니다.
동시에, 출력은 ‘’가 ‘+’인 RFC1738에 따라 문자열 변환될 수 있습니다.

```
assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');
```

## <a name="security"></a>보안

[@ljharb](https://github.com/ljharb)으로 메일을 보내거나 보고할 잠재적인 보안 취약성이 있는 경우 https://tidelift.com/security 를 참조하세요.

## <a name="qs-for-enterprise"></a>기업용 qs

Tidelift 구독의 일부로 사용 가능

qs 및 수천 개의 다른 패키지의 유지 관리자는 Tidelift와 협력하여 애플리케이션을 구축하는 데 사용하는 오픈 소스 종속성에 대한 상업적 지원 및 유지 관리를 제공하고 있습니다. 사용하는 정확한 종속성의 유지 관리자에게 비용을 지불하면서 시간을 절약하고, 위험을 줄이고, 코드 상태를 개선합니다. [자세한 정보](https://tidelift.com/subscription/pkg/npm-qs?utm_source=npm-qs&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)

[1]: https://npmjs.org/package/qs
[2]: http://versionbadg.es/ljharb/qs.svg
[3]: https://api.travis-ci.org/ljharb/qs.svg
[4]: https://travis-ci.org/ljharb/qs
[5]: https://david-dm.org/ljharb/qs.svg
[6]: https://david-dm.org/ljharb/qs
[7]: https://david-dm.org/ljharb/qs/dev-status.svg
[8]: https://david-dm.org/ljharb/qs?type=dev
[9]: https://ci.testling.com/ljharb/qs.png
[10]: https://ci.testling.com/ljharb/qs
[11]: https://nodei.co/npm/qs.png?downloads=true&stars=true
[license-image]: http://img.shields.io/npm/l/qs.svg
[license-url]: LICENSE
[downloads-image]: http://img.shields.io/npm/dm/qs.svg
[downloads-url]: http://npm-stat.com/charts.html?package=qs
