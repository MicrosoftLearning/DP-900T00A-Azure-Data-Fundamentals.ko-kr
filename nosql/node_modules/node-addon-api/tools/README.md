---
ms.openlocfilehash: 3decbdeed6f0c742925a5be9b78f5251a4c0b569
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052161"
---
# <a name="tools"></a>도구

## <a name="clang-format"></a>clang-format

clang 형식 검사 도구는 지정된 git-refs에 비해 변경된 코드 줄을 확인하도록 설계되었습니다.

## <a name="migration-script"></a>마이그레이션 스크립트

마이그레이션 도구는 마이그레이션 프로세스에서 반복적인 작업을 줄이도록 설계되었습니다. 그러나 스크립트가 모든 항목을 변환하는 것을 목표로 하는 것은 아닙니다. 일반적으로 몇 가지 작은 수정 및 주요 재구성이 필요합니다.

### <a name="how-to-use"></a>사용 방법

변환 스크립트를 실행하려면 먼저 `node_modules` 디렉터리에 최신 `node-addon-api` 버전이 있는지 확인합니다.
```
npm install node-addon-api
```

그런 다음 프로젝트 디렉터리를 전달하는 스크립트를 실행합니다.
```
node ./node_modules/node-addon-api/tools/conversion.js ./
```

완료되면 스크립트에서 누락된 항목을 다시 컴파일하고 디버그합니다.


### <a name="quick-fixes"></a>빠른 수정
다음은 쉽게 해결할 수 있는 항목 목록입니다.
  1. JavaScript에 값을 반환하지 않는 경우 메서드의 반환 값을 void로 변경합니다.
  2. `.`를 사용하여 특성에 액세스하거나 `->` 대신 Napi::Object에서 멤버 함수를 호출합니다.
  3. `Napi::New(env, value);`~'Napi::[Type]::New(env, value);


### <a name="major-reconstructions"></a>주요 재구성
`Napi::ObjectWrap`의 구현은 NAN의 구현과 크게 다릅니다. `Napi::ObjectWrap`은 래핑된 개체에 대한 포인터를 사용하고 ObjectWrap 생성자 내에서 래핑된 개체에 대한 참조를 만듭니다. `Napi::ObjectWrap` 또한 래핑된 개체의 인스턴스 메서드를 NAN과 같은 정적 메서드 대신 Javascript 모듈에 연결합니다.

따라서 모듈에서 Nan::ObjectWrap을 사용하는 경우 다음 단계를 실행해야 합니다.

  1. [ClassName]::New 함수를 `Napi::CallbackInfo`를 사용하는 생성자 함수로 변환합니다. 다음으로 선언
```
[ClassName](const Napi::CallbackInfo& info);
```
및 다음으로 정의
```
[ClassName]::[ClassName](const Napi::CallbackInfo& info) : Napi::ObjectWrap<[ClassName]>(info){
  ...
}
```
이렇게 하면 개체가 인스턴스화된 후 `Napi::ObjectWrap` 생성자가 호출되고 `Napi::ObjectWrap`은 `this` 포인터를 사용하여 래핑된 개체에 대한 참조를 만들 수 있습니다.

  2. 원래 생성자 코드를 새 생성자로 이동합니다. 원래 생성자를 삭제합니다.
  3. 클래스 초기화 함수에서 다음과 같은 방법으로 네이티브 메서드를 연결합니다.
```
Napi::FunctionReference constructor;

void [ClassName]::Init(Napi::Env env, Napi::Object exports, Napi::Object module) {
  Napi::HandleScope scope(env);
  Napi::Function ctor = DefineClass(env, "Canvas", {
    InstanceMethod<&[ClassName]::Func1>("Func1"),
    InstanceMethod<&[ClassName]::Func2>("Func2"),
    InstanceAccessor<&[ClassName]::ValueGetter>("Value"),
    StaticMethod<&[ClassName]::StaticMethod>("MethodName"),
    InstanceValue("Value", Napi::[Type]::New(env, value)),
  });

  constructor = Napi::Persistent(ctor);
  constructor .SuppressDestruct();
  exports.Set("[ClassName]", ctor);
}
```
  4. NAN에서 ObjectWrap을 래핑 해제해야 하는 함수(예: `[ClassName]* native = Nan::ObjectWrap::Unwrap<[ClassName]>(info.This());`)에서는 `this` 포인터가 각 ObjectWrap 인스턴스가 고유한 개체 인스턴스와 연결되므로 래핑되지 않은 개체로 직접 포인터를 사용합니다.


이 가이드를 수행한 후에도 여전히 문제가 발견되면 문제를 설명하는 문제를 남겨 주세요. 문제를 해결하려고 노력하겠습니다.
