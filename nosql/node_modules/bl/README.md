---
ms.openlocfilehash: f9f95f626a5d55dca7937d56df8b3dd3b7040164
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052338"
---
# <a name="bl-bufferlist"></a>bl *(BufferList)*

[![빌드 상태](https://api.travis-ci.com/rvagg/bl.svg?branch=master)](https://travis-ci.com/rvagg/bl/)

**Node.js 버퍼 목록 수집기, 판독기, 스트리머 항목입니다.**

[![NPM](https://nodei.co/npm/bl.svg)](https://nodei.co/npm/bl/)

**bl** 은 노드 버퍼의 컬렉션에 대한 스토리지 개체로, 기본 버퍼 읽기 가능한 API를 사용하여 노출합니다. 또한 이중 스트림으로 작동하므로 버퍼를 내보내는 스트림에서 버퍼를 수집하고 버퍼를 사용하는 스트림으로 내보낼 수 있습니다!

원래 버퍼는 그대로 유지되고 복사본은 필요에 따라 수행됩니다. 단일 원래 버퍼를 사용해야 하는 모든 읽기는 해당 버퍼의 조각만 반환합니다(원래 버퍼와 동일한 메모리 참조). 스팬 버퍼를 읽는 경우 필요에 따라 연결을 수행하고 결과를 투명하게 반환합니다.

```js
const { BufferList } = require('bl')

const bl = new BufferList()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(Buffer.from('j'))
bl.append(Buffer.from([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

console.log(bl.indexOf('def')) // 3
console.log(bl.indexOf('asdf')) // -1

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\u0003\u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
```

생성자에서 콜백을 제공하고 **[concat-stream](https://github.com/maxogden/node-concat-stream)** 과 마찬가지로 사용합니다.

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

fs.createReadStream('README.md')
  .pipe(BufferListStream((err, data) => { // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  }))
```

이와 같이 콜백 메서드를 사용하는 경우 결과 `data` 매개 변수는 목록에 있는 모든 `Buffer` 개체의 연결입니다. 이 연결의 오버헤드를 방지하려는 경우(극단적인 성능 의식의 경우) 콜백 메서드를 피하고 표준 Stream처럼 대신 `'end'`를 수신 대기합니다.

또는 [hyperquest](https://github.com/substack/hyperquest)를 사용하여 URL을 가져오려면([요청](http://github.com/mikeal/request) 및 일반 노드 http에서도 작동해야 합니다!)

```js
const hyperquest = require('hyperquest')
const { BufferListStream } = require('bl')

const url = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(BufferListStream((err, data) => {
  console.log(data.toString())
}))
```

또는 읽기 가능한 스트림으로 사용하여 버퍼 목록을 출력 원본으로 다시 구성합니다.

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

var bl = new BufferListStream()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append(Buffer.from('hi'))
bl.append(Buffer.from('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
```

## <a name="api"></a>API

  * <a href="#ctor"><code><b>new BufferList([ buf ])</b></code></a>
  * <a href="#isBufferList"><code><b>BufferList.isBufferList(obj)</b></code></a>
  * <a href="#length"><code>bl.<b>length</b></code></a>
  * <a href="#append"><code>bl.<b>append(buffer)</b></code></a>
  * <a href="#get"><code>bl.<b>get(index)</b></code></a>
  * <a href="#indexOf"><code>bl.<b>indexOf(value[, byteOffset][, encoding])</b></code></a>
  * <a href="#slice"><code>bl.<b>slice([ start[, end ] ])</b></code></a>
  * <a href="#shallowSlice"><code>bl.<b>shallowSlice([ start[, end ] ])</b></code></a>
  * <a href="#copy"><code>bl.<b>copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])</b></code></a>
  * <a href="#duplicate"><code>bl.<b>duplicate()</b></code></a>
  * <a href="#consume"><code>bl.<b>consume(bytes)</b></code></a>
  * <a href="#toString"><code>bl.<b>toString([encoding, [ start, [ end ]]])</b></code></a>
  * <a href="#readXX"><code>bl.<b>readDoubleBE()</b></code>, <code>bl.<b>readDoubleLE()</b></code>, <code>bl.<b>readFloatBE()</b></code>, <code>bl.<b>readFloatLE()</b></code>, <code>bl.<b>readInt32BE()</b></code>, <code>bl.<b>readInt32LE()</b></code>, <code>bl.<b>readUInt32BE()</b></code>, <code>bl.<b>readUInt32LE()</b></code>, <code>bl.<b>readInt16BE()</b></code>, <code>bl.<b>readInt16LE()</b></code>, <code>bl.<b>readUInt16BE()</b></code>, <code>bl.<b>readUInt16LE()</b></code>, <code>bl.<b>readInt8()</b></code>, <code>bl.<b>readUInt8()</b></code></a>
  * <a href="#ctorStream"><code><b>new BufferListStream([ callback ])</b></code></a>

--------------------------------------------------------
<a name="ctor"></a>
### <a name="new-bufferlist-buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferList([ 버퍼 | 버퍼 배열 | BufferList | BufferList 배열 | 문자열 ])
생성자에는 인수가 필요하지 않지만 단일 `Buffer` 개체 또는 `Buffer` 개체 배열을 전달하여 목록을 초기화할 수 있습니다.

`new`는 반드시 필요한 것은 아닙니다. 새 개체를 인스턴스화하지 않으면 자동으로 수행되므로 다음을 사용하여 새 인스턴스를 만들 수 있습니다.

```js
const { BufferList } = require('bl')
const bl = BufferList()

// equivalent to:

const { BufferList } = require('bl')
const bl = new BufferList()
```

--------------------------------------------------------
<a name="isBufferList"></a>
### <a name="bufferlistisbufferlistobj"></a>BufferList.isBufferList(obj)
전달된 개체가 `BufferList`인지 여부를 확인합니다. 전달된 객체가 `BufferList` **또는** `BufferListStream`의 인스턴스이면 `true`를 반환하고 그렇지 않으면 `false`를 반환합니다.

N.B. 이 정적 메서드가 추가되기 전에 이 라이브러리 버전에서 생성된 `BufferList` 또는 `BufferListStream` 인스턴스에 대해 `true`를 반환하지 않습니다.

--------------------------------------------------------
<a name="length"></a>
### <a name="bllength"></a>bl.length
목록의 길이를 바이트 단위로 가져옵니다. 이 값은 목록에 포함된 모든 버퍼의 길이에 대한 합계로, 처음에 반소용 버퍼에 대한 초기 오프셋을 뺀 값입니다. 목록에서 읽을 수 있는 총 바이트 수를 정확하게 나타내야 합니다.

--------------------------------------------------------
<a name="append"></a>
### <a name="blappendbuffer--buffer-array--bufferlist--bufferlist-array--string"></a>bl.append(버퍼 | 버퍼 배열 | BufferList | BufferList 배열 | 문자열)
`append(buffer)`는 내부 목록에 추가 버퍼 또는 BufferList를 추가합니다. `this`는 연결될 수 있도록 반환됩니다.

--------------------------------------------------------
<a name="get"></a>
### <a name="blgetindex"></a>bl.get(index)
`get()`은 지정된 인덱스에서 바이트를 반환합니다.

--------------------------------------------------------
<a name="indexOf"></a>
### <a name="blindexofvalue-byteoffset-encoding"></a>bl.indexOf(value[, byteOffset][, encoding])
`get()`은 지정된 인덱스에서 바이트를 반환합니다.
`indexOf()` 메서드는 BufferList에서 지정된 요소를 찾을 수 있는 첫 번째 인덱스 또는 없는 경우 -1을 반환합니다.

--------------------------------------------------------
<a name="slice"></a>
### <a name="blslice-start--end--"></a>bl.slice([ start, [ end ] ])
`slice()`는 지정된 범위 내의 바이트를 포함하는 새 `Buffer` 개체를 반환합니다. `start` 및 `end` 둘 다 선택 사항이며 기본적으로 목록의 시작과 끝으로 설정됩니다.

요청된 범위가 단일 내부 버퍼에 걸쳐 있으면 해당 버퍼의 원래 메모리 범위를 공유하는 해당 버퍼의 조각이 반환됩니다. 범위가 여러 버퍼에 걸쳐 있는 경우 복사 작업이 발생하여 균일한 버퍼를 제공할 수 있습니다.

--------------------------------------------------------
<a name="shallowSlice"></a>
### <a name="blshallowslice-start--end--"></a>bl.shallowSlice([ start, [ end ] ])
`shallowSlice()`는 지정된 범위 내의 바이트를 포함하는 새 `BufferList` 개체를 반환합니다. `start` 및 `end` 둘 다 선택 사항이며 기본적으로 목록의 시작과 끝으로 설정됩니다.

복사본은 수행되지 않습니다. 결과의 모든 버퍼는 원래 목록과 메모리를 공유합니다.

--------------------------------------------------------
<a name="copy"></a>
### <a name="blcopydest--deststart--srcstart--srcend---"></a>bl.copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])
`copy()`는 `destStart`부터 시작하고 `srcStart`에서 `srcEnd`까지 지정된 범위 내의 바이트를 포함하는 `dest` 버퍼에 있는 목록의 콘텐츠를 복사합니다. `destStart`, `start`, `end`는 선택 사항이며 기본값은 각각 `dest` 버퍼의 시작과 목록의 시작과 끝입니다.

--------------------------------------------------------
<a name="duplicate"></a>
### <a name="blduplicate"></a>bl.duplicate()
`duplicate()`는 목록의 **shallow-copy** 를 수행합니다. 내부 버퍼는 동일하게 유지되므로 기본 버퍼를 변경하는 경우 변경 내용이 원본과 중복 모두에 반영됩니다. 이 메서드는 `consume()` 또는 `pipe()`를 호출하고 원래 목록을 유지하려는 경우에 필요합니다. 예제:

```js
var bl = new BufferListStream()

bl.append('hello')
bl.append(' world')
bl.append('\n')

bl.duplicate().pipe(process.stdout, { end: false })

console.log(bl.toString())
```

--------------------------------------------------------
<a name="consume"></a>
### <a name="blconsumebytes"></a>bl.consume(bytes)
`consume()`은 바이트를 목록 시작 부분으로 이동합니다. 사용된 바이트 수는 내부 버퍼의 크기와 일치할 필요가 없습니다. 데이터의 일관된 보기를 제공하기 위해 초기 오프셋이 그에 따라 계산됩니다.

--------------------------------------------------------
<a name="toString"></a>
### <a name="bltostringencoding--start--end-"></a>bl.toString([encoding, [ start, [ end ]]])
`toString()`은 버퍼의 문자열 표현을 반환합니다. 선택적 `start` 및 `end` 인수는 `slice()`에 전달되고 `encoding`은 결과 버퍼의 `toString()`에 전달됩니다. 자세한 내용은 [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end) 문서를 참조하세요.

--------------------------------------------------------
<a name="readXX"></a>
### <a name="blreaddoublebe-blreaddoublele-blreadfloatbe-blreadfloatle-blreadint32be-blreadint32le-blreaduint32be-blreaduint32le-blreadint16be-blreadint16le-blreaduint16be-blreaduint16le-blreadint8-blreaduint8"></a>bl.readDoubleBE(), bl.readDoubleLE(), bl.readFloatBE(), bl.readFloatLE(), bl.readInt32BE(), bl.readInt32LE(), bl.readUInt32BE(), bl.readUInt32LE(), bl.readInt16BE(), bl.readInt16LE(), bl.readUInt16BE(), bl.readUInt16LE(), bl.readInt8(), bl.readUInt8()

`Buffer` 인터페이스의 모든 표준 바이트 판독 메서드가 구현되며 내부 버퍼 경계에서 투명하게 작동합니다.

작동 방식은 <b><code>[Buffer](http://nodejs.org/docs/latest/api/buffer.html)</code></b> 문서를 참조하세요.

--------------------------------------------------------
<a name="ctorStream"></a>
### <a name="new-bufferliststream-callback--buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferListStream([ 콜백 | 버퍼 | 버퍼 배열 | BufferList | BufferList 배열 | 스트링 ])
**BufferListStream** 은 노드 **[이중 스트림](http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex)** 이므로 표준 노드 스트림처럼 읽고 쓸 수 있습니다. **BufferListStream** 인스턴스에서 `pipe()`할 수도 있습니다.

생성자는 선택적 콜백을 사용합니다. 제공되는 경우 `bl.end()`가 호출될 때(즉, 파이프된 스트림에서) **bl** 인스턴스에 대한 참조가 뒤따르는 오류 인수와 함께 콜백이 호출됩니다. 이는 특히 스트림이 네트워크 스트림과 같이 두툼한 경우 스트림의 전체 콘텐츠를 수집하는 편리한 방법입니다.

일반적으로 생성자에는 인수가 필요하지 않지만 단일 `Buffer` 개체 또는 `Buffer` 개체의 배열을 전달하여 목록을 초기화할 수 있습니다.

`new`는 반드시 필요한 것은 아닙니다. 새 개체를 인스턴스화하지 않으면 자동으로 수행되므로 다음을 사용하여 새 인스턴스를 만들 수 있습니다.

```js
const { BufferListStream } = require('bl')
const bl = BufferListStream()

// equivalent to:

const { BufferListStream } = require('bl')
const bl = new BufferListStream()
```

N.B. 이전 버전과의 호환성을 위해 `require('bl')`하는 경우 `BufferListStream`이 **기본** 내보내기입니다.

```js
const { BufferListStream } = require('bl')
// equivalent to:
const BufferListStream = require('bl')
```

--------------------------------------------------------

## <a name="contributors"></a>참가자

**bl** 은 다음 해커에 의해 사용자에게 제공됩니다.

 * [Rod Vagg](https://github.com/rvagg)
 * [Matteo Collina](https://github.com/mcollina)
 * [Jarett Cruger](https://github.com/jcrugzz)

<a name="license"></a>
## <a name="license-amp-copyright"></a>라이선스 및 저작권

Copyright (c) 2013-2019 bl 기여자(위에 나열됨).

bl은 MIT 라이선스에 따라 라이선스가 부여됩니다. MIT 라이선스에 명시적으로 부여되지 않은 모든 권한은 예약되어 있습니다. 자세한 내용은 포함된 LICENSE.md 파일을 참조하세요.
