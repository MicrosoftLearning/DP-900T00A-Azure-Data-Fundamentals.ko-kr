---
ms.openlocfilehash: 6e78f9de8f21b6501e007e86f631942016f041dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052217"
---
# <a name="jsbi--pure-javascript-bigints-build-statushttpstravis-cicomgooglechromelabsjsbi-jsbi-on-npmhttpswwwnpmjscompackagejsbi"></a>JSBI — pure-JavaScript BigInts [![빌드 상태](https://travis-ci.com/GoogleChromeLabs/jsbi.svg?branch=main)](https://travis-ci.com/GoogleChromeLabs/jsbi) [![의 npm jsbi](https://img.shields.io/npm/v/jsbi)](https://www.npmjs.com/package/jsbi)

JSBI는 [ECMAScript BigInt 제안의 순수](https://tc39.es/proposal-bigint/) JavaScript 구현으로, ES2020에서 공식적으로 JavaScript 언어의 일부가 되었습니다.

## <a name="installation"></a>설치

```sh
npm install jsbi --save
```

## <a name="usage"></a>사용량

```js
import JSBI from './jsbi.mjs';

const max = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
console.log(String(max));
// → '9007199254740991'
const other = JSBI.BigInt('2');
const result = JSBI.add(max, other);
console.log(String(result));
// → '9007199254740993'
```

참고: 숫자 표현(예: `String(max)` 또는 `max.toString()`)을 보기 위해 `console.log()`에서 인스턴스를 호출할 때 모든 `JSBI` 인스턴스에서 `toString`을 명시적으로 호출합니다. 값이 없으면(예: `console.log(max)`) 대신 값을 나타내는 개체가 표시됩니다.

[babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint)를 사용하여 JSBI 코드를 네이티브 BigInt 코드로 변환합니다.

자세한 내용은 아래의 자세한 지침을 참조하세요.

## <a name="why"></a>그 이유는

최신 브라우저(이 글을 작성하는 시점에 Google Chrome 67+, Opera 54+, Firefox 68 이상) 및 Node.js(v10.4+)에서는 [Native BigInts를 이미 제공 중](https://v8.dev/features/bigint)이며 향후 다른 브라우저에서도 제공할 것입니다. 즉, 코드를 모든 곳에서 실행하려는 경우에는 아직 사용할 수 없습니다.

현재 코드에서 BigInts를 사용하려면 라이브러리가 필요합니다. 그러나 문제가 있습니다. BigInt 제안은 BigInts에서 작동하도록 연산자(예: `+`, `>=` 등)의 동작을 변경합니다. 이러한 변경 내용은 직접 폴리필할 수 없습니다. 그리고 (대부분의 경우) Babel 또는 유사한 도구를 사용하여 코드를 대체하기 위해 BigInt 코드를 변환할 수 없게 만듭니다. 그 이유는 이러한 변환이 프로그램의 모든 단일 연산자를 입력 형식 검사를 수행하는 일부 함수에 대한 호출로 대체해야 하므로 허용되지 않는 성능 저하가 발생하기 때문입니다.

해결 방법은 라이브러리 구문을 사용하여 코드를 작성하고 사용 가능한 경우 [native BigInt 코드로 변환](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint)하는 것입니다. JSBI는 정확히 이 목적을 위해 설계되었습니다. 이 구현은 예정된 native BigInts와 똑같이 동작하는 BigInt “폴리필” 구현을 제공하지만, 오늘날 모든 브라우저에서 제공할 수 있는 구문을 제공합니다.

기존의 다른 큰 정수 라이브러리에 비해 장점은 다음과 같습니다.

- 사용할 수 있게 되면 native BigInts와 똑같이 작동하므로 이를 마이그레이션하기 위해 코드 구문을 [기계적으로](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) 업데이트할 수 있습니다. 따라서 논리를 다시 생각할 필요가 없습니다.
- 성능에 중점을 줍니다. 평균적으로 JSBI는 Google Chrome이 현재 제공 중인 네이티브 구현과 성능 경쟁력이 있습니다.

## <a name="how"></a>방법은?

구문의 기계적 차이를 제외하고 [네이티브 BigInts를 사용하는 것처럼](https://developers.google.com/web/updates/2018/05/bigint) JSBI-BigInts를 사용합니다. `BigInt`를 `JSBI.BigInt`로 바꾼 후에는 일부 항목도 동일하게 표시됩니다.

| 작업            | native BigInts          | JSBI                     |
| -------------------- | ----------------------- | ------------------------ |
| 문자열에서 만들기 | `a = BigInt('456')`     | `a = JSBI.BigInt('456')` |
| 숫자에서 만들기 | `a = BigInt(789)`       | `a = JSBI.BigInt(789)`   |
| 문자열로 변환 | `a.toString(radix)`     | `a.toString(radix)`      |
| 숫자로 변환 | `Number(a)`             | `JSBI.toNumber(a)`       |
| 잘림           | `BigInt.asIntN(64, a)`  | `JSBI.asIntN(64, a)`     |
|                      | `BigInt.asUintN(64, a)` | `JSBI.asUintN(64, a)`    |
| 형식 검사           | `typeof a === 'bigint'` | `a instanceof JSBI`      |

대부분의 연산자는 메서드 호출로 대체됩니다.

| 작업                   | native BigInts | JSBI                              |
| --------------------------- | -------------- | --------------------------------- |
| 더하기                    | `c = a + b`    | `c = JSBI.add(a, b)`              |
| 빼기                 | `c = a - b`    | `c = JSBI.subtract(a, b)`         |
| 곱하기              | `c = a * b`    | `c = JSBI.multiply(a, b)`         |
| 나누기                    | `c = a / b`    | `c = JSBI.divide(a, b)`           |
| 나머지                   | `c = a % b`    | `c = JSBI.remainder(a, b)`        |
| 지수              | `c = a ** b`   | `c = JSBI.exponentiate(a, b)`     |
| 부정                    | `b = -a`       | `b = JSBI.unaryMinus(a)`          |
| 비트 부정 연산            | `b = ~a`       | `b = JSBI.bitwiseNot(a)`          |
| 왼쪽 이동               | `c = a << b`   | `c = JSBI.leftShift(a, b)`        |
| 오른쪽 이동              | `c = a >> b`   | `c = JSBI.signedRightShift(a, b)` |
| 비트 “and”               | `c = a & b`    | `c = JSBI.bitwiseAnd(a, b)`       |
| 비트 “or”                | `c = a \| b`   | `c = JSBI.bitwiseOr(a, b)`        |
| 비트 “xor”               | `c = a ^ b`    | `c = JSBI.bitwiseXor(a, b)`       |
| 다른 BigInts와 비교 | `a === b`      | `JSBI.equal(a, b)`                |
|                             | `a !== b`      | `JSBI.notEqual(a, b)`             |
|                             | `a < b`        | `JSBI.lessThan(a, b)`             |
|                             | `a <= b`       | `JSBI.lessThanOrEqual(a, b)`      |
|                             | `a > b`        | `JSBI.greaterThan(a, b)`          |
|                             | `a >= b`       | `JSBI.greaterThanOrEqual(a, b)`   |

위의 함수는 BigInts에서만 작동합니다. (이러한 검사는 사용자가 무엇을 하고 있는지 알고 있다고 가정할 때 시간 낭비이기 때문에 현재 구현에서 형식 검사를 수행하지 않습니다. 다른 입력을 사용하여 호출하지 마세요. 그렇지 않으면 “흥미로운” 오류가 발생합니다!)

일부 작업은 BigInt를 숫자와 비교하거나 문자열을 BigInt와 연결하는 등 혼합 형식의 입력을 제공할 때 특히 흥미롭습니다. 각 네이티브 연산자의 이름을 따서 명명된 정적 함수로 구현됩니다.

| 작업                       | native BigInts | JSBI             |
| ------------------------------- | -------------- | ---------------- |
| 추상 같음 비교    | `x == y`       | `JSBI.EQ(x, y)`  |
| 제네릭 “같지 않음”             | `x != y`       | `JSBI.NE(x, y)`  |
| 제네릭 “보다 작음”             | `x < y`        | `JSBI.LT(x, y)`  |
| 제네릭 “작거나 같음”    | `x <= y`       | `JSBI.LE(x, y)`  |
| 제네릭 “보다 큼”          | `x > y`        | `JSBI.GT(x, y)`  |
| 제네릭 “크거나 같음” | `x >= y`       | `JSBI.GE(x, y)`  |
| 제네릭 추가                | `x + y`        | `JSBI.ADD(x, y)` |

여기에서 변수 이름 `x` 및 `y`는 해당 변수가 모든 항목(예: `JSBI.GT(101.5, BigInt('100'))` 또는 `str = JSBI.ADD('result: ', BigInt('0x2A'))`)을 참조할 수 있음을 나타냅니다.

아쉽게도 지원되지 않는 몇 가지 사항도 있습니다.

| 지원되지 않는 작업 | native BigInts | JSBI                                 |
| --------------------- | -------------- | ------------------------------------ |
| 리터럴              | `a = 123n;`    | N/A ☹                                |
| increment             | `a++`          | N/A ☹                                |
|                       | `a + 1n`       | `JSBI.add(a, JSBI.BigInt('1'))`      |
| 감소             | `a--`          | N/A ☹                                |
|                       | `a - 1n`       | `JSBI.subtract(a, JSBI.BigInt('1'))` |

정적 함수를 사용하여 네이티브 `++` 및 `--` 연산자의 정확한 동작을 복제하는 것은 불가능합니다. JSBI는 결국 사라지도록 의도되었으므로 유사하지만 다른 대안을 제공하지 않습니다. 대신 `JSBI.add()` 및 `JSBI.subtract()`를 사용해야 합니다.

## <a name="when"></a>언제?

지금! JSBI 라이브러리는 지금 사용할 수 있습니다.

BigInts가 모든 곳에서 기본적으로 지원되면 [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint)를 사용하여 JSBI 코드를 네이티브 BigInt 코드로 변환합니다.

[문제 추적기](https://github.com/GoogleChromeLabs/jsbi/issues)를 확인하여 JSBI에 대한 향후 계획에 대해 자세히 알아보고 토론에 참여하세요!

더 모호한 향후 계획은 JSBI 라이브러리(또는 확장)를 추가 BigInt 관련 기능을 위한 준비 지점으로 사용하는 것입니다. 공식 제안은 의도적으로 다소 미미하며 후속 제안에 대한 추가 “라이브러리 기능”을 남깁니다. 예를 들어 결합된 `exp`+`mod` 함수와 비트 조작 함수가 있습니다.

## <a name="development"></a>개발

1. 이 리포지토리 및 `cd`를 로컬 디렉터리에 복제합니다.

1. `.nvmrc`에 지정된 Node.js 버전을 사용합니다.

     ```sh
     nvm use
     ```

1. 개발 종속성을 설치합니다.

    ```sh
    npm install
    ```

1. 테스트를 실행합니다.

    ```sh
    npm test
    ```

    전체 명령 목록을 보려면 `npm run`을 참조하세요.

## <a name="for-maintainers"></a>유지 관리자

### <a name="how-to-publish-a-new-release"></a>새 릴리스를 게시하는 방법

1. `main` 분기의 `package.json`에서 버전 번호를 이동합니다.

    ```sh
    npm version patch -m 'Release v%s'
    ```

    `patch` 대신 필요에 따라 `minor` 또는 `major` [를 사용합니다](https://semver.org/).

    그러면 Git 커밋 + 태그가 생성됩니다.

1. 릴리스 커밋 및 태그 푸시:

    ```sh
    git push
    ```

    그러면 CI가 새 릴리스를 npm에 자동으로 게시합니다.
