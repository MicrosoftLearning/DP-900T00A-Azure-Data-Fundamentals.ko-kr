---
ms.openlocfilehash: ca2cf748b426d17058b55202a60ece01d9e05592
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052410"
---
# <a name="node-abort-controller"></a>node-abort-controller

EventEmitter 기반 Node.JS에 대한 AbortController 폴리필

[![빌드 상태](https://dev.azure.com/stfaul/node-abort-controller/_apis/build/status/southpolesteve.node-abort-controller?branchName=master)](https://dev.azure.com/stfaul/node-abort-controller/_build/latest?definitionId=3&branchName=master)

## <a name="usage"></a>사용량

```js
import fetch from 'node-fetch'
import AbortController from 'node-abort-controller'

const controller = new AbortController()
const signal = controller.signal

await fetch('https:/www.google.com', { signal })

// Abort after 500ms. Effectively a timeout
setTimeout(() => controller.abort(), 500)
```

## <a name="why-would-i-use-this"></a>왜 이것을 사용하나요?

필요하지 않을 수도 있습니다! 일반적으로 JavaScript 코드에서 실행할 수 있는 세 가지 환경은 다음과 같습니다.

- 노드
- 최신 브라우저(Internet Explorer 아님)
- 레거시 브라우저(대부분 Internet Explorer)

최신 JS API의 경우 각 환경은 폴리필을 사용하는 것이 가장 좋습니다.

- 필요한 경우에만
- 플랫폼에만 적용됩니다.

실제로 이것은 어렵습니다. 웹팩 및 브라우저화와 같은 도구는 모든 환경에서 모든 항목이 기본으로 작동하는지 확인하는 데 유용합니다. 그러나 위의 두 지점에서는 모두 실패하기가 매우 쉽습니다. 거의 대부분의 경우 필요하지 않은 플랫폼에서 이상적인 폴리필보다 적게 배송하게 됩니다. 그렇다면 개발자는 무엇을 해야 할까요? `fetch` 및 `AbortController`의 경우 제가 작업을 완료했습니다. 이것은 이 작업에 대한 가이드입니다.

다음을 구축하는 경우...

#### <a name="application-running-in-modern-browsers"></a>최신 브라우저에서 실행되는 애플리케이션:

축하합니다! 라이브러리나 폴리필이 전혀 필요하지 않습니다! 이 탭을 닫습니다. 이 패키지를 제거합니다.

#### <a name="application-running-in-modern-browsers-and-node-such-as-a-server-side-rendered-js-app"></a>최신 브라우저 및 노드(예: 서버 쪽 렌더링된 JS 앱)에서 실행되는 애플리케이션:

이 패키지및 [node-fetch](https://www.npmjs.com/package/node-fetch)를 사용합니다. 이것이 최소한으로 필요한 것입니다.

#### <a name="application-supporting-legacy-browsers-and-not-node"></a>레거시 브라우저 및 NOT 노드를 지원하는 애플리케이션:

[abort-controller](https://www.npmjs.com/package/abort-controller) 및 [whatwg-fetch](https://www.npmjs.com/package/whatwg-fetch)를 사용합니다. 이는 모든 브라우저 환경에서 작동하는 보다 완전한 폴리필입니다.

#### <a name="application-supporting-legacy-browsers-and-node"></a>레거시 브라우저 및 노드를 지원하는 애플리케이션:

[abort-controller](https://www.npmjs.com/package/abort-controller) 및 [cross-fetch](https://www.npmjs.com/package/cross-fetch)를 사용합니다. 위와 동일하며, cross-fetch를 제외하면 브라우저와 node.js 모두에서 올바르게 폴리필됩니다.

#### <a name="library-being-consumed-by-other-applications-and-using-fetch-internally"></a>다른 애플리케이션에서 사용하고 내부적으로 `fetch`를 사용하는 라이브러리:

이 패키지및 [node-fetch](https://www.npmjs.com/package/node-fetch)를 사용합니다. 최종 사용자를 위한 가장 작고 의견이 적은 조합입니다. Internet Explorer를 대상으로 하는 애플리케이션 개발자는 `AbortController` 및 `fetch`를 직접 폴리필해야 합니다. 그러나 라이브러리는 최신 브라우저만 대상으로 하는 개발자에게 비일관적인 폴리필을 강제하지 않습니다.

## <a name="goals"></a>목표

위의 가이드를 염두에 두고 이 라이브러리에는 매우 구체적인 목표 집합이 있습니다.

1. node.js에 최소 폴리필 제공
2. 브라우저 환경에서 폴리필을 제공하지 마세요.

이는 `fetch` 및 `AbortController`를 내부적으로 사용하고 브라우저와 노드 개발자 _모두_ 를 대상으로 하는 라이브러리 작성자에게 적합합니다.

## <a name="prior-art"></a>이전 아트

https://github.com/mysticatea/abort-controller 에 대해 @mysticatea 에 감사합니다. 이는 환상적인 `AbortController` 폴리필이며 많은 사용 사례에 이상적입니다.
